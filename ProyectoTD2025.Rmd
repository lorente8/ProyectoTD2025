---
title: "ProyectoTD2025"
author: "Mar Alemany, Martín González, Mateo Reina, Sina Taheri, Adrian Mena, Sergio Nadal"
date: "2025-03-28"
output: 
  rticles::mdpi_article:
    extra_dependencies: ["booktabs", "longtable"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Introducción

En la actualidad, la digitalización de los tickets de compra se ha convertido en una práctica común en grandes cadenas de supermercados. Estos tickets electrónicos, enviados en formato PDF al correo del cliente, no solo reducen el uso de papel, sino que también generan datos valiosos que pueden ser analizados para obtener información relevante sobre los hábitos de consumo, la evolución de precios y las preferencias de los compradores.

Este proyecto tiene como objetivo desarrollar un sistema de análisis automatizado que permita extraer, procesar y visualizar la información contenida en los tickets de Mercadona. Mediante técnicas de tratamiento de datos en R, exploraremos patrones de compra, identificaremos los productos más vendidos, analizaremos la evolución temporal de los precios y determinaremos tendencias en función de la ubicación de la tienda y el momento de la compra.

# Material y Métodos

Para llevar a cabo este proyecto se han seleccionando un conjunto de librerías específicas que respondieran a los distintos requerimientos del análisis. 

Para la manipulación de datos se emplearon los paquetes tidyverse (incluyendo dplyr y stringr), que permitieron realizar operaciones de filtrado, transformación y procesamiento de texto de manera eficiente. La extracción del contenido textual desde los archivos PDF se realizó mediante el paquete pdftools, capaz de preservar la estructura original de los documentos.

Las visualizaciones se generaron utilizando ggplot2, seleccionado por su versatilidad para crear gráficos de alta calidad. Para la presentación de resultados en formatos reproducibles se implementó knitr, facilitando la integración de código, resultados y texto explicativo.

Utilizaremos dos data frames para manejar los datos de manera más eficiente. El primer data frame contendrá la información general del ticket, como la dirección del supermercado, la fecha y hora de la compra, el monto total, entre otros. En este caso, todos los productos registrados en el ticket se almacenarán como una sola cadena de texto en una única variable. El segundo data frame desglosará los productos en variables separadas

Ambos data frames estarán vinculados a través de la variable fs (factura simplificada).

```{r, include=FALSE}
#Nos aseguramos de que no haya nada cargado en el Environment
rm(list=ls())

# Especificamos las librerías necesarias en esta lista
packages = c("knitr","tidyverse", "ggplot2", "dplyr", "pdftools", "stringr", "corrplot")
# Cargar los paquetes, sino están intalados, se instalarán automáticamente y serán cargados
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos='http://cran.rediris.es')
    library(x, character.only = TRUE)
  }
})
```

# Importación de los datos
## Carga de ficheros

Para evitar errores durante el procesamiento posterior, se realizó un cambio en los nombres de los archivos PDF originales. Los archivos fueron renombrados de forma secuencial con un formato estándar. Esta acción se llevó a cabo una única vez, y por ello el código correspondiente fue comentado en el script, con el fin de prevenir que los archivos se sobrescriban accidentalmente al ejecutar el programa más de una vez.

```{r, include=FALSE}
#Obtener lista de archivos PDF en la carpeta
#archivos <- list.files(path =  "./data" , pattern = "\\.pdf$", full.names = #FALSE, ignore.case = TRUE)

# Renombrar archivos secuencialmente
#for (i in seq_along(archivos)) {
#  nombre_actual <- file.path(ruta_carpeta, archivos[i])
#  extension <- file_ext(archivos[i])
#  nombre_nuevo <- file.path(ruta_carpeta, paste0("M", i, ".", extension))
  
#  file.rename(from = nombre_actual, to = nombre_nuevo)
#}
```

Se procedió a cargar automáticamente todos los archivos PDF contenidos en la carpeta de trabajo designada. Para ello, se empleó una función que permite listar únicamente los archivos con extensión .pdf, garantizando así que solo se consideren los documentos relevantes para el análisis. Esta carga automatizada facilita el procesamiento por lotes y evita la necesidad de seleccionar manualmente cada archivo.

```{r, include=FALSE}
# Obtener lista de archivos PDF en la carpeta
archivos <- list.files(path =  "./data" , pattern = "\\.pdf$", full.names = TRUE, ignore.case = TRUE)
#print(archivos)

n_archivos <- length(archivos)

```

Para el proyecto se han importado un total de `r n_archivos` archivos.

## Carga de datos

Se construyó un data frame a partir de los datos extraídos, realizando las transformaciones necesarias para asegurar que cada variable tuviera el formato y tipo de dato adecuados.

Para la lectura de los archivos PDF se utilizaron funciones de la librería pdftools, mientras que la limpieza y manipulación de las cadenas de texto se llevó a cabo con funciones de la librería stringr.

Durante el procesamiento, se asignó el tipo de dato Date a la variable de fecha y se convirtieron en valores numéricos las variables decimales como el total de la compra, la base imponible y la cuota de IVA. Cabe señalar que muchos de los datos no pueden incorporarse directamente al data frame, ya que en el formato original aparecen combinados en una misma línea. Es el caso de la fecha, la hora y el número de operación, que debieron separarse y asignarse a variables distintas.


```{r tabla_variables, echo=FALSE, results='asis'}
vars <- c("comercio", "empresa", "direccion", "cp", "telefono", "fecha", "hora", 
          "op", "fs", "productos", "total", "forma_pago", "base_imp", "cuota")
desc <- c("Nombre del comercio", "Tipo y código de empresa", "Dirección del comercio", 
          "Código postal", "Teléfono del comercio", "Fecha de la compra (día-mes-año)", 
          "Hora de la compra (horas y minutos)", "Número del código de la operación", 
          "Código de la factura simplificada", "Lista con los productos comprados", 
          "Dinero total de la compra", "Forma de pago (tarjeta o en efectivo)", 
          "Base imponible (IVA)", "Cuota del IVA")

tabla <- data.frame(Variable = vars, Descripción = desc)

knitr::kable(tabla, align = 'c', format = "latex", booktabs = TRUE,
             caption = "Descripción de variables")



```

Las variables finales obtenidas se pueden observar en la Tabla \ref{tab:tabla_variables}.

Por razones de espacio y legibilidad, no se muestra en el documento el conjunto de datos (df), ya que contiene un número elevado de observaciones y variables. 


```{r, echo = FALSE}
comercio <- c() #nombre del comercio
empresa <- c() #tipo y código de empresa
direccion <- c() 
cp <- c() #código postal
telefono <- c() #Misma línea, tendremos que separar estos valores
fecha <- c()
hora <- c()
op <- c()
fs <- c()#factura
productos <- c() #lista con los productos comprados
total <- c() #total de la compra
forma_pago <- c()

#IVA
base_imp <- c() #Base imponible
cuota <- c() #Cuota 

```


```{r, include = FALSE}
for (archivo in archivos) {
  
  pdf <- pdf_text(archivo) #leemos le archivo pdf
  ticket <- trimws(strsplit(pdf,split = "\n")[[1]]) #separamos por líneas
  ticket <- ticket[grep(".", ticket)] #quitamos las líneas vacías

  #procesamos los datos del ticket
  linea_comercio <- ticket[1]
  linea_direccion <- ticket[2]
  linea_cp <- ticket[3]
  linea_telefono <- ticket[4]
  linea_fecha_hora_op <- ticket[5]
  linea_fs <- ticket[6]
  p = 8 
  linea_productos <- ticket[p]
    #unimos todos los productos en un solo caracter
  while (ticket[p+1] != ticket[grep("TOTAL", ticket)[1]]){
    p = p + 1
    linea_productos <- paste(linea_productos, ticket[p],sep = ";")
  }
  linea_total <- ticket[grep("TOTAL", ticket)[1]]
  linea_forma_pago <- ticket[p+2]
  linea_iva <- ticket[grep("TOTAL", ticket)[2]]
  
  #extraemos los datos
  com <- strsplit(linea_comercio,", ")[[1]]
  comercio <- c(comercio, com[1])
  empresa <- c(empresa, com[2])
  direccion <- c(direccion, trimws(linea_direccion))
  cp_info <- strsplit(trimws(linea_cp), " ")[[1]]
  cp <- c(cp, cp_info[1])
  telefono <- c(telefono, trimws(gsub("TELÉFONO:", "", linea_telefono)))
  fecha_hora_op <- strsplit(trimws(linea_fecha_hora_op), " ")[[1]]
  fecha_hora_op <- fecha_hora_op[grep(".", fecha_hora_op)]
  fecha <- c(fecha, fecha_hora_op[1])
  hora <- c(hora, fecha_hora_op[2])
  op <- c(op, gsub("OP:", "", fecha_hora_op[4]))
  fs <- c(fs, gsub("FACTURA SIMPLIFICADA:", "", linea_fs))
  productos <- c(productos, linea_productos)
  total <- c(total, trimws(gsub("TOTAL [(]€[)]", "", linea_total)))
  formapago <- strsplit(linea_forma_pago," ")[[1]]
  forma_pago <- c(forma_pago, paste0(formapago[1],formapago[2]))
  base_couta <- strsplit(trimws(linea_iva),split = " ")[[1]]
  base_couta <- base_couta[grep(".", base_couta)]
  base_imp <- c(base_imp,base_couta[2])
  cuota <- c(cuota, base_couta[3])
  
}


```


```{r , include= FALSE}
df <- data.frame(comercio, empresa, direccion, cp, telefono, fecha, hora, 
                 op, fs, productos, total, forma_pago, base_imp, cuota,
                 stringsAsFactors = FALSE)

#Modificamos las clases de los datos
df$fecha <- as.Date(df$fecha,format = "%d/%m/%Y")
df$anio <- as.numeric(format(df$fecha, "%Y"))
df$mes <- as.numeric(format(df$fecha, "%m"))
df$dia <- as.numeric(format(df$fecha, "%d"))
# Elimina la columna fecha
#df$fecha <- NULL

# Separar la columna fs en tres partes
fs_split <- strsplit(df$fs, "-")
# Crear las nuevas columnas a partir del resultado
df$num_tienda <- sapply(fs_split, function(x) x[1])
df$num_caja <- sapply(fs_split, function(x) x[2])
df$num_ticket <- sapply(fs_split, function(x) x[3])
# Eliminar la columna original fs
df$fs <- NULL
df$comercio <- NULL
df$empresa <- NULL


df$total <- as.numeric(gsub(pattern = ",",replacement = ".",df$total))
df$base_imp <- as.numeric(gsub(pattern = ",",replacement = ".",df$base_imp))
df$cuota <- as.numeric(gsub(pattern = ",",replacement = ".",df$cuota))
```


```{r, include= FALSE}
aparcamientos <- c()
for (archivo in archivos) {
  pdf <- pdf_text(archivo)
  ticket <- trimws(strsplit(pdf, split = "\n")[[1]])
  aparcamiento_lineas <- grep("Aparcamiento", ticket, value = TRUE)
  if (length(aparcamiento_lineas) > 0) {
    aparcamientos <- c(aparcamientos, paste(aparcamiento_lineas, collapse = " "))
  } else {
    aparcamientos <- c(aparcamientos, NA)
  }
}
df_aparcamiento <- data.frame(archivo = archivos, aparcamiento = aparcamientos, stringsAsFactors = FALSE)

```

# Analizamos los productos

La información relativa a los productos comprados se encontraba inicialmente agrupada dentro de una única columna del data frame principal. Para facilitar su análisis, se extrajo esta columna a un nuevo data frame, separando los productos que venían concatenados en una misma celda.

```{r, include=FALSE}
df_producto <- df %>% select(c(num_ticket, productos)) %>% 
  separate_rows(productos, sep = ";")
```


## Productos pescateria

El procesamiento de los productos se realizó en varias etapas, según el tipo de producto y la forma en que aparecían en el ticket. En primer lugar, se identificaron los productos de pescadería, que siguen un formato particular: aparecen siempre precedidos por una línea con la palabra "PESCADO", seguida del nombre del producto en la línea siguiente y de los detalles de compra (peso, precio por kilo y total) en una tercera línea. A partir de esta estructura, se extrajeron los datos relevantes y se almacenaron en un nuevo data frame específico para pescado.


```{r, include=FALSE}
# Procesamiento de pescado por kg

# Identificar filas con "PESCADO"
filas_pescado <- which(df_producto$productos == "PESCADO")

# Inicializar vectores para almacenar datos
num_ticket_vec <- character()
nombre_producto_vec <- character()
peso_kg_vec <- numeric()
precio_kg_vec <- numeric()
precio_total_vec <- numeric()

for (i in seq_along(filas_pescado)) {
  idx <- filas_pescado[i]
  
  # Extraer información básica
  num_ticket <- df_producto$num_ticket[idx]
  nombre <- df_producto$productos[idx + 1]  # Nombre en la siguiente fila
  
  # Procesar la fila de detalles
  detalles <- df_producto$productos[idx + 2]
  
  # Limpiar y dividir la cadena de detalles
  detalles_limpio <- gsub(",", ".", detalles)  # Reemplazar comas por puntos
  detalles_split <- strsplit(trimws(detalles_limpio), "\\s+")[[1]]
  
  # Extraer valores (asumiendo orden: peso, unidad, precio_kg, moneda, precio_total)
  if (length(detalles_split) >= 5) {
    peso_kg <- as.numeric(detalles_split[1])
    precio_kg <- as.numeric(detalles_split[3])
    importe <- as.numeric(detalles_split[5])
    
    # Almacenar en vectores
    num_ticket_vec <- c(num_ticket_vec, num_ticket)
    nombre_producto_vec <- c(nombre_producto_vec, nombre)
    peso_kg_vec <- c(peso_kg_vec, peso_kg)
    precio_kg_vec <- c(precio_kg_vec, precio_kg)
    precio_total_vec <- c(precio_total_vec, importe)
  }
}

df_pescado <- data.frame(
  num_ticket = num_ticket_vec,
  nombre = nombre_producto_vec,
  peso_kg = peso_kg_vec,
  precio_kg = precio_kg_vec,
  importe = precio_total_vec,
  stringsAsFactors = FALSE
)

```

```{r tabla_pescado, echo =FALSE, results='asis'}
# Mostrar el dataframe df_pescado en formato tabla
knitr::kable(head(df_pescado, 10), align = 'c', format = "latex", booktabs = TRUE,
             caption = "Datos procesados para productos de pescadería")

```

En la siguiente tabla \ref{tab:tabla_pescado} se pueden observar los datos procesados para los productos de pescadería .

## Productos vendidos por peso

Después, se eliminaron las filas correspondientes a productos de pescadería para poder trabajar exclusivamente con los productos que también se venden por peso, como frutas y verduras. Estos artículos generalmente constan de dos líneas: la primera contiene el nombre del producto y la segunda incluye el peso, el precio por kilogramo y el importe total. A partir de esta estructura se construyó un segundo data frame con las frutas y verduras, extrayendo y transformando la información necesaria.


```{r, include= FALSE}
# Procesamiento fruta y la verdura

#Identificar TODOS los bloques de pescado (3 filas cada uno)
bloques_pescado <- which(df_producto$productos == "PESCADO")

# Crear vector con TODAS las filas a eliminar (cada bloque son 3 filas)
filas_a_eliminar <- unlist(lapply(bloques_pescado, function(x) x:(x+2)))

# Eliminar todos los bloques
df_sin_pescado <- df_producto[-filas_a_eliminar, ]

ind_detalles_kg <- grep("kg.*€/kg", df_sin_pescado$productos, value = FALSE)

df_fruta_verdura <- data.frame(
  num_ticket = df_sin_pescado$num_ticket[ind_detalles_kg],
  nombre = df_sin_pescado$productos[ind_detalles_kg - 1],
  detalles = df_sin_pescado$productos[ind_detalles_kg],
  stringsAsFactors = FALSE
) %>%
mutate(
  # Limpiar el nombre (eliminar números iniciales)
  nombre = gsub("^\\d+\\s*", "", nombre),
  
  # Extraer peso (kg) - primer número en la línea
  peso_kg = as.numeric(gsub(",", ".", str_extract(detalles, "^[0-9,]+"))),
  
  # Extraer precio por kg - método mejorado
  precio_kg = as.numeric(gsub(",", ".", 
    str_extract(detalles, "[0-9,]+(?=\\s*€/kg)"))),
  
  # Extraer importe total - último número en la línea
  importe = as.numeric(gsub(",", ".", 
    str_extract(detalles, "[0-9,]+$")))
) %>%
select(-detalles)

```

```{r tabla_fruta_verdura, echo=FALSE, results='asis'}
knitr::kable(head(df_fruta_verdura, 10), align = 'c', format = "latex", booktabs = TRUE,
             caption = "Descripción de variables del conjunto de frutas y verduras")

```

En la siguiente tabla \ref{tab:tabla_fruta_verdura} se pueden observar los datos procesados para los productos de fruta y verdura .


## Productos vendidos por unidad

Una vez separados los productos por peso, se procedió a procesar el resto de productos, es decir, aquellos que se venden por unidades. En este caso, se extrajeron datos como la cantidad, el nombre del producto, el precio unitario y el importe total. Se aplicaron técnicas de procesamiento de texto para limpiar y estructurar la información, ya que algunos productos con una sola unidad incluían el precio directamente dentro del nombre del producto.


```{r, include= FALSE}
# Procesamiento resto de productos sin kg

# Identificar las filas de detalles (kg y €/kg)
ind_detalles_kg <- grep("kg.*€/kg", df_sin_pescado$productos, value = FALSE)

# Las filas de nombres están justo antes de los detalles
ind_nombres_kg <- ind_detalles_kg - 1

# Combinar todos los índices a eliminar
filas_fruta_verdura <- sort(unique(c(ind_nombres_kg, ind_detalles_kg)))

# Eliminar filas ya procesadas
df_resto <- df_sin_pescado[-filas_fruta_verdura, ]

df_productos_unidades <- df_resto %>%
  mutate(
    # 1. Extraer cantidad (siempre es el primer número)
    cantidad = as.numeric(str_extract(productos, "^\\d+")),
    
    # 2. Extraer posible precio en el nombre (para productos de 1 unidad)
    precio_en_nombre = ifelse(cantidad == 1,
                            as.numeric(gsub(",", ".", str_extract(productos, "\\d+,\\d+$"))),
                            NA_real_),
    
    # 3. Procesamiento vectorizado de componentes
    componentes = strsplit(productos, "\\s+"),
    
    # 4. Extraer importe normal (para productos con múltiples unidades)
    importe_normal = sapply(componentes, function(x) {
      if(length(x) >= 3) as.numeric(gsub(",", ".", x[length(x)])) else NA_real_
    }),
    
    # 5. Determinar el importe final
    importe = ifelse(!is.na(precio_en_nombre), precio_en_nombre, importe_normal),
    
    # 6. Extraer descripción limpia (MODIFICACIÓN CLAVE)
    nombre = mapply(function(comp, prod, cant, precio_nombre) {
      # Primero eliminar la cantidad inicial (si existe)
      nombre_limpio <- gsub("^\\d+\\s*", "", prod)
      
      if(length(comp) <= 2) return(nombre_limpio)  # Caso simple
      
      if(!is.na(precio_nombre)) {
        # Para productos de 1 unidad: eliminar precio final
        gsub("\\s+\\d+,\\d+$", "", nombre_limpio)
      } else {
        # Para múltiples unidades: eliminar elementos numéricos finales
        paste(comp[2:(length(comp)-2)], collapse=" ")
      }
    }, componentes, productos, cantidad, precio_en_nombre, SIMPLIFY = TRUE) %>%
      str_trim()  # Eliminar espacios sobrantes
  ) %>%
  mutate(
    # 7. Calcular precio unitario
    precio_unitario = importe / cantidad
  ) %>%
  select(num_ticket, nombre, cantidad, precio_unitario, importe)
```

```{r tabla_productos_unidad, echo=FALSE, results='asis'}


knitr::kable(head(df_productos_unidades, 10), align = 'c', format = "latex", booktabs = TRUE,
             caption = "Descripción de variables del conjunto de productos por unidad")

```

En la siguiente tabla \ref{tab:tabla_productos_unidad} se pueden observar los datos procesados para los productos por unidad .


## Conjunto completo de productos

Finalmente, los tres grupos de productos —pescado, frutas y verduras, y productos por unidades— se combinaron en un único data frame unificado. A este conjunto se le añadió una columna adicional que indicaba si el ticket incluía un servicio de aparcamiento, en caso de que esa información estuviera disponible. El resultado fue un data frame final, estructurado y homogéneo, con todos los productos organizados por tipo, cantidad, precio, importe y número de ticket, listo para su análisis posterior.


```{r, include=FALSE}
# dataframe final con todos los productos analizados:

# Añadir columna 'tipo' a cada dataframe
df_pescado <- df_pescado %>% mutate(tipo = "pescado")
df_fruta_verdura <- df_fruta_verdura %>% mutate(tipo = "fruta_verdura")
df_productos_unidades <- df_productos_unidades %>% mutate(tipo = "unidades")

# Unificar columnas para combinar
df_final <- bind_rows(
  df_pescado %>% select(num_ticket, nombre, cantidad = peso_kg, precio = precio_kg, importe, tipo),
  df_fruta_verdura %>% select(num_ticket, nombre, cantidad = peso_kg, precio = precio_kg, importe, tipo),
  df_productos_unidades %>% select(num_ticket, nombre = nombre, cantidad, precio = precio_unitario, importe, tipo)
)

# Crear columna tiene_aparcamiento 
if ("aparcamiento" %in% colnames(df_aparcamiento)) {
  df_aparcamiento <- df_aparcamiento %>%
    mutate(nombre_archivo = basename(archivo)) %>%
    mutate(num_ticket = str_extract(nombre_archivo, "\\d+")) %>%
    mutate(tiene_aparcamiento = !is.na(aparcamiento)) %>%
    select(num_ticket, tiene_aparcamiento)

  # Convertir num_ticket a carácter en ambos dataframes
  df_final <- df_final %>% mutate(num_ticket = as.character(num_ticket))
  df_aparcamiento <- df_aparcamiento %>% mutate(num_ticket = as.character(num_ticket))

  # Combinar los datos
  df_final <- left_join(df_final, df_aparcamiento, by = "num_ticket")
} else {
  df_final$tiene_aparcamiento <- NA  # columna vacía si no existe 'aparcamiento'
}

# Resultado final ordenado
df_final <- df_final %>% arrange(num_ticket)


```

```{r tabla_final, echo=FALSE, results='asis'}

knitr::kable(head(df_final, 10), align = 'c', format = "latex", booktabs = TRUE,
             caption = "Descripción de variables del conjunto de datos final")

```

En la siguiente tabla \ref{tab:tabla_final} se pueden observar los datos procesados para los productos por unidad .



# Analisis exploratorio

## Datos faltantes
Realizamos una comprobación para asegurarnos de que el data frame no contenga valores faltantes (exceptuando la variable aparcamiento, ya que cuando no se encuentra disponible, se asigna un valor NA). En caso de encontrar valores faltantes en otras variables, eliminamos las filas correspondientes.

```{r, include=FALSE}
# Comprobación de valores faltantes en df_final
# Excluimos la columna 'tiene_aparcamiento' si existe

# Verificar si hay valores faltantes en el dataframe
missing_data <- df_final %>% select(-tiene_aparcamiento) %>% summarise_all(~ sum(is.na(.)))


# Si se encuentran valores faltantes, eliminamos las filas correspondientes
df_final <- df_final %>% select(-tiene_aparcamiento) %>% drop_na()


```

## Análisis univariante 

Comenzaremos el análisis de las variables dividiéndolas en dos grupos: las variables categóricas y las variables numéricas.

### Variables categóricas

Las variables categóricas representan cualidades o características, y en nuestro data frame están codificadas como tipo character.

En el data frame de los tickets, la mayoría de las variables son de tipo categórico. Una de las más relevantes es la variable num_ticket, que es única para cada ticket y sirve como identificador.

Otras variables categóricas en nuestro análisis incluyen comercio y empresa, que son constantes en todos los tickets. Sin embargo, esta estructura está pensada por si en el futuro se incluyen tickets de otros comercios o empresas. De manera similar, tenemos la variable forma_pago, que actualmente solo contiene registros de pagos realizados con tarjeta, pero se mantiene por si en algún ticket hay pagos en efectivo.

```{r include=FALSE}
n_comercio <- length(unique(df_final$comercio))
n_empresa <- length(unique(df_final$empresa))
n_forma_pago <- length(unique(df_final$forma_pago))

```
En cuanto a las variables categóricas en el data frame de productos, tenemos tipo, que clasifica los productos en categorías como "pescado", "fruta_verdura" y "unidades". Además, la variable nombre contiene los nombres de los productos.

En total, tenemos `r n_comercio` valores únicos en comercio, `r n_empresa` valores únicos en empresa, y `r n_forma_pago` valores únicos en forma_pago.
```{r, include=FALSE}
n_tipo <- length(unique(df_final$tipo))
n_nombre_producto <- length(unique(df_final$nombre))

```

También observamos que tenemos `r n_tipo` tipos diferentes de productos y `r n_nombre_producto` productos distintos registrados en total.

### Variables de tipo numérico

as variables numéricas representan cantidades o medidas cuantitativas dentro del conjunto de datos. En nuestro análisis, nos centramos principalmente en dos variables clave: cantidad (ya sea en unidades o en kilos) y precio (precio por kilo o unitario, según el tipo de producto).

Para tener una visión general del comportamiento de las compras, primero calculamos el valor total gastado, sumando el importe de todos los productos. Además, analizamos cuántos productos se compran por ticket (es decir, la media de la suma de cantidades por cada ticket) y cuál es el gasto medio por ticket.

```{r, include=FALSE}
# Total gastado en todos los productos
precio_total <- sum(df_final$importe, na.rm = TRUE)

# Agrupación por ticket para calcular total de productos por ticket
productos_por_ticket <- df_final %>%
  group_by(num_ticket) %>%
  summarise(total_productos = sum(cantidad, na.rm = TRUE))

# Media de productos comprados por ticket
media_productos_ticket <- mean(productos_por_ticket$total_productos, na.rm = TRUE)

# Gastos por ticket
importe_por_ticket <- df_final %>%
  group_by(num_ticket) %>%
  summarise(total_importe = sum(importe, na.rm = TRUE))

# Media de importe por ticket
media_importe_ticket <- mean(importe_por_ticket$total_importe, na.rm = TRUE)

cat("El gasto total en todos los productos es:", round(precio_total, 2), "€\n")
cat("La media de productos comprados por ticket es:", round(media_productos_ticket, 2), "\n")
cat("La media del importe total por ticket es:", round(media_importe_ticket, 2), "€\n")

```
El gasto total en todos los productos es: 14022.5 €
La media de productos comprados por ticket es: 19.9 
La media del importe total por ticket es: 48.35 €

Además, observamos que la variable cantidad contiene valores decimales en algunos casos, lo que se debe a que ciertos productos (como frutas, verduras o pescado) se venden al peso, mientras que otros se venden por unidades enteras.

A continuación, mostramos un resumen de las cantidades redondeadas para tener una idea de las frecuencias de compra por tipo de producto:
```{r, echo=FALSE}
fac <- df_final %>%
  mutate(cantidad_redondeada = round(cantidad, 0)) %>%
  pull(cantidad_redondeada) %>%
  as.factor()

tabla_frecuencias <- table(fac)
tabla_frecuencias_df <- as.data.frame(tabla_frecuencias)
kable(tabla_frecuencias_df, col.names = c("Cantidad Redondeada", "Frecuencia"), 
      caption = "Frecuencia de Cantidades Redondeadas de Productos Comprados")
```
Con esto, podemos observar que en la mayoría de los casos se compraron 1 o 2 unidades/kilos, siendo 1 la cantidad más frecuente.

## Análisis multivariable

**Relación entre la Dirección y las Ganancias**
En este apartado analizamos si existe alguna relación entre la localización del supermercado (variable dirección) y los ingresos obtenidos. Para ello, generamos dos gráficos: uno que muestra la ganancia total por dirección y otro que representa la ganancia media por ticket en cada localización.

```{r grafica1, echo = FALSE, fig.width=5.7,fig.height=3.5, out.width='90%'}
df %>%
  group_by(direccion) %>%
  summarise(
    ventas = n(),
    ganancia_total = sum(total, na.rm = TRUE)
  ) %>%
  ggplot(aes(x = direccion, y = ganancia_total)) +
  geom_point() +
  geom_text(aes(label = ventas), hjust = 1.5, vjust = 0.5) +
  labs(
    title = "Ganancia total por dirección",
    x = "Dirección",
    y = "Ganancia total (€)"
  ) +
  theme(
    axis.text.x = element_text(angle = 60, hjust = 1, size = 6),
    legend.position = "right"
  )

```
En el gráfico anterior se puede observar que muchas direcciones cuentan únicamente con una venta registrada. Sin embargo, hay dos supermercados que destacan por tener un número de tickets significativamente superior al resto. En general, se aprecia que a mayor número de tickets, mayor es la ganancia total. 

A continuación, comparamos las ganancias promedio por venta en cada supermercado, para entender mejor su rendimiento individual más allá del volumen total de ventas.

```{r grafica2, echo = FALSE, fig.width=5.7,fig.height=4, out.width='90%'}
df %>%
  group_by(direccion) %>%
  summarise(
    ventas = n(),
    ganancia_media = mean(total, na.rm = TRUE)
  ) %>%
  ggplot(aes(x = direccion, y = ganancia_media)) +
  geom_point() +
  geom_text(aes(label = ventas), hjust = 1.5, vjust = 0.5) +
  labs(
    title = "Ganancia media por dirección",
    x = "Dirección",
    y = "Ganancia media por ticket (€)"
  ) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1, size = 6))

```
 En este segundo gráfico vemos que el supermercado ubicado en Calle Alicante 83 sigue destacando en ingresos, aunque es el de Avenida del Textil el que presenta una mayor ganancia media por ticket. Esto sugiere un rendimiento más eficiente, a pesar de no tener el mayor volumen de ventas.

**Relación entre el Número de Productos y el Precio Total por Ticket**

En este apartado analizamos si existe una relación directa entre el número de productos comprados en un ticket y el precio total pagado en dicho ticket. Para ello, realizamos un gráfico de dispersión y calculamos el coeficiente de correlación de Pearson.

```{r grafica3, echo=FALSE, out.width='85%'}
library(dplyr)

# Total de productos por ticket
productos_por_ticket <- df_final %>%
  group_by(num_ticket) %>%
  summarise(total_productos = sum(cantidad, na.rm = TRUE))

# Total gastado por ticket
precios_por_ticket <- df_final %>%
  group_by(num_ticket) %>%
  summarise(precios = sum(importe, na.rm = TRUE))



# Unir el número de productos por ticket con los precios por ticket
datos_completos <- merge(productos_por_ticket, precios_por_ticket, by = "num_ticket")

# Crear un gráfico de dispersión
ggplot(datos_completos, aes(x = total_productos, y = precios)) +
  geom_point(color = "blue") +
  labs(
    title = "Relación entre número de productos y precio total del ticket",
    x = "Número de productos por ticket",
    y = "Importe total (€)"
  ) +
  theme_minimal()

# Calcular correlación de Pearson
cant_precio <- cor(datos_completos$total_productos, datos_completos$precios,
                   method = 'pearson') 
cant_precio <- round(cant_precio, digits = 2)

```

El gráfico anterior muestra cómo varía el importe total del ticket en función del número de productos adquiridos. Cada punto representa un ticket diferente.

El coeficiente de correlación de Pearson es r cant_precio, un valor cercano a $1$, lo cual indica que existe una relación lineal positiva muy fuerte entre ambas variables. Es decir, cuantos más productos se compran en un ticket, mayor es el importe total pagado, lo que resulta coherente con el comportamiento esperado en compras de supermercado.

\bigskip


# Preguntas

## - ¿Cuáles son los 5 productos, de los vendidos por unidades, con más ventas ? ¿Cuántas unidades de cada uno se han vendido ? ¿Y por kilos?
```{r, echo=FALSE}
# Productos más vendidos por unidades
unidades <- df_final[df_final$tipo == "unidades", ]
unidades_agrupadas <- aggregate(cantidad ~ nombre, data = unidades, sum)
unidades_ordenadas <- unidades_agrupadas[order(-unidades_agrupadas$cantidad), ]

productos_mas_vendidos_unidades <- head(unidades_ordenadas, n = 5)
productos_mas_vendidos_unidades %>%
  kable(caption = "Top 5 productos más vendidos por unidades")

# Productos más vendidos por kilos (pescado y fruta_verdura)
kilos <- df_final[df_final$tipo %in% c("pescado", "fruta_verdura"), ]
kilos_agrupados <- aggregate(cantidad ~ nombre, data = kilos, sum)
kilos_ordenados <- kilos_agrupados[order(-kilos_agrupados$cantidad), ]

productos_mas_vendidos_kilos <- head(kilos_ordenados, n = 5)
productos_mas_vendidos_kilos %>%
  kable(caption = "Top 5 productos más vendidos por kilos")


```
## -Si consideramos la categoría de FRUTAS Y VERDURAS. Cuáles son los 5 productos más vendidos ? ¿Cuántos kilos se han vendido de cada uno de estos productos ?
```{r, echo=FALSE, warning=FALSE}
# Filtrar solo productos de la categoría fruta_verdura
frutas_verduras <- df_final[df_final$tipo == "fruta_verdura", ]

fv_agrupado <- aggregate(cantidad ~ nombre, data = frutas_verduras, sum)

fv_ordenado <- fv_agrupado[order(-fv_agrupado$cantidad), ]

top5_frutas_verduras <- head(fv_ordenado, 5)

top5_frutas_verduras %>%
  kable(caption = "Top 5 productos más vendidos en la categoría Frutas y Verduras (en kilos)", col.names = c("Producto", "Kilos vendidos"))

```
## -Si consideramos la categoría de PESCADO. Cuáles son los 5 productos más vendidos ? ¿Cuántos kilos se han vendido de cada uno de estos productos ?
```{r, echo=FALSE, warning=FALSE}
pescado <- df_final[df_final$tipo == "pescado", ]

pescado_agrupado <- aggregate(cantidad ~ nombre, data = pescado, sum)

pescado_ordenado <- pescado_agrupado[order(-pescado_agrupado$cantidad), ]

top5_pescado <- head(pescado_ordenado, 5)

top5_pescado %>%
  kable(caption = "Top 5 productos más vendidos en la categoría Pescado (en kilos)", col.names = c("Producto", "Kilos vendidos"))

```

## -Muestra mediante un gráfico de líneas como ha variado el precio por kilo de las bananas y los plátanos en los tickets disponibles, a lo largo del tiempo.
```{r, echo=FALSE, warning=FALSE,  fig.width=5.7,fig.height=4, out.width='90%'}

df_final <- df_final %>%
  mutate(nombre = tolower(nombre),
         nombre = case_when(
           nombre %in% c("platano", "plátano", "platanos") ~ "plátano",
           nombre %in% c("banana", "bananas") ~ "banana",
           TRUE ~ nombre
         ))

banana_platano <- df_final %>%
  filter(nombre %in% c("banana", "plátano")) %>%
  left_join(df %>% select(num_ticket, fecha), by = "num_ticket") %>%
  filter(!is.na(fecha))

  ggplot(banana_platano, aes(x = fecha, y = precio, color = nombre)) +
    geom_line(aes(group = nombre), alpha = 0.7) +
    geom_point(size = 1.2, alpha = 0.6) +
    labs(title = "Evolución del Precio por Kilo: Banana y Plátano",
         x = "Fecha",
         y = "Precio por Kilo (€)",
         color = "Producto") +
    theme_minimal()


```

## -¿Desde qué ciudades se emiten más tickets?
```{r, echo=FALSE, fig.width=5.7,fig.height=4, out.width='90%'}
# Contamos los tickets por cada dirección
tickets_por_mercadona <- df %>%
  group_by(direccion) %>%
  summarise(n_tickets = n_distinct(num_ticket)) %>%
  arrange(desc(n_tickets)) 

ggplot(tickets_por_mercadona, aes(x = reorder(direccion, n_tickets), y = n_tickets)) +
  geom_point(aes(color = n_tickets), size = 4, alpha = 0.7) +  
  geom_text(aes(label = n_tickets), vjust = -0.5, size = 3) +  
  labs(title = "Número de Tickets Emitidos por Ciudad",
       x = "Ciudad", y = "Número de Tickets") +
  theme_minimal() +
  scale_color_gradient(low = "lightblue", high = "blue") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 

```

La ciudad con más tickets emitidos es:  C/ QUART 120Con un total de  51 tickets

## -Muestra mediante un diagrama el número de tickets recogidos cada día de las semana. ¿Si tuvieses que cerrar un día entre semana qué día lo harías ?

```{r, echo=FALSE, fig.width=5.7,fig.height=4, out.width='90%'}

df$fecha <- as.Date(df$fecha)

df$dow <- wday(df$fecha, label = TRUE, abbr = FALSE, week_start = 1)

tickets_por_dia <- df %>%
  group_by(dow) %>%
  summarise(n_tickets = n_distinct(num_ticket)) %>%
  arrange(match(dow, c("lunes", "martes", "miércoles", "jueves", "viernes", "sábado", "domingo")))

ggplot(tickets_por_dia, aes(x = dow, y = n_tickets, fill = dow)) +
  geom_col(show.legend = FALSE) +
  geom_text(aes(label = n_tickets), vjust = -0.5, size = 3) +
  labs(title = "Número de Tickets por Día de la Semana",
       x = "Día de la semana",
       y = "Número de tickets") +
  theme_minimal()

```
Si se tubiera que cerrar un dia entre semana este seria el jueves que es el dia que menos tickets se recogen.


## -¿Qué productos han generado mayor ingreso total (precio x cantidad)?
```{r, echo=FALSE}
df_final$ingreso_total <- df_final$precio * df_final$cantidad

productos_ordenados <- df_final[order(-df_final$ingreso_total), ]

productos_top <- head(productos_ordenados[, c("nombre", "ingreso_total")], 5)

productos_top %>%
  kable(caption = "Top 5 productos con mayor ingreso total")


```


## -¿Cuál es el ticket con el mayor importe total y qué porcentaje representa este ticket respecto al importe total de todos los tickets?
  
```{r, include=FALSE}
importe_por_ticket <- df_final %>%
  group_by(num_ticket) %>%
  summarise(importe_total = sum(importe, na.rm = TRUE)) %>%
  arrange(desc(importe_total))

ticket_mayor <- head(importe_por_ticket, 1)

total_ventas <- sum(df_final$importe, na.rm = TRUE)

porcentaje <- round((ticket_mayor$importe_total / total_ventas) * 100, 2)

list(
  ticket_con_mayor_importe = ticket_mayor,
  porcentaje_del_total = paste0(porcentaje, "%")
)


```
Respuesta: El ticket con el mayor importe total es el número 397921, con un importe de 234,82 euros.
Este ticket constituye el 1,67% del importe total de todos los tickets. \par
 
## -¿Qué productos se compran habitualmente juntos? ¿Que podemos entender sobre la dieta de los clientes?
```{r, echo=FALSE, warning=FALSE}
product_pairs <- df_final %>% rename(item1 = nombre) %>% inner_join(df_final, by = "num_ticket") %>%
rename(item2 = nombre) %>% filter(item1 < item2)  
                         
pair_counts <- product_pairs %>% group_by(item1, item2) %>% summarise(frequency = n(), .groups = "drop") %>%
arrange(desc(frequency))



head(pair_counts, 10) %>%
  kable(caption = "Los 10 productos que más se compran juntos")


```
Se han identificado pares de productos más frecuentemente comprados juntos, donde uno de ellos es casi siempre QUESO LONCHAS CABRA. Eso sugiere que este producto es muy popular y acompaña a muchos otros productos a la misma compra.


## -¿Existen diferencias de precios para el mismo producto en diferentes tiendas o ubicaciones?
```{r,echo=FALSE, warning=FALSE}

# Unimos para tener la dirección asociada al ticket
df_completo <- left_join(df_final, df %>% select(num_ticket, direccion), by = "num_ticket")


diferencias_precio <- df_completo %>%
  group_by(nombre, direccion, precio) %>%
  summarise(n = n(), .groups = "drop") %>%
  arrange(nombre, direccion)

diferencias_precio %>%
  head(10) %>%
  kable(caption = "Diferencias de precios para el mismo producto en diferentes tiendas")



```


## -¿A que horas del dia hay más ventas?
```{r, echo=FALSE, fig.width=5.7,fig.height=4, out.width='90%'}
df$hora <- as.POSIXct(df$hora, format = "%H:%M")  
df$hora_limpia <- hour(df$hora)

gasto_diario <- df %>% 
  group_by(hora_limpia) %>%
  summarise(gasto_total_diario = sum(total, na.rm = TRUE)) %>%
  arrange(desc(gasto_total_diario))

ggplot(gasto_diario, aes(x = factor(hora_limpia), y = gasto_total_diario)) +
  geom_col(fill = "steelblue", show.legend = FALSE) +  
  labs(title = "Gasto total por horas del día",
       x = "Hora del día (de 0 a 23)",
       y = "Gasto total (€)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```


## -En cuantos tickets se venden frutas/verduras y pescados?
```{r, echo=FALSE}
# Contamos los tickets en los que se venden frutas/verduras
tickets_fruta_verdura <- df_fruta_verdura %>%
  summarise(n_tickets = n_distinct(num_ticket)) 


# Contamos los tickets en los que se venden pescados
tickets_pescado <- df_pescado %>%
  summarise(n_tickets = n_distinct(num_ticket))

```
Número de tickets en los que se venden frutas/verduras:  168 
Número de tickets en los que se venden pescados:  24 


## -¿Existen diferencias de consumo por cada mercadona?
```{r,echo=FALSE,  fig.width=5.7,fig.height=4, out.width='90%'}

gasto_por_mercadona <- df %>%
  group_by(direccion) %>%
  summarise(
    media_gasto = mean(total, na.rm = TRUE),
    mediana_gasto = median(total, na.rm = TRUE),
    desv_gasto = sd(total, na.rm = TRUE)
  ) %>%
  arrange(desc(media_gasto)) 

kable(gasto_por_mercadona, caption = "Estadísticas de Gasto Promedio, Mediana y Desviación Estándar por Mercadona", booktabs = TRUE)

ggplot(gasto_por_mercadona, aes(x = reorder(direccion, media_gasto), y = media_gasto, fill = direccion)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  geom_text(aes(label = round(media_gasto, 2)), vjust = -0.5) +
  labs(title = "Gasto Promedio por Mercadona", x = "Mercadona", y = "Gasto Promedio (€)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```


## -¿Que mes y que dia del año es cuando mas dinero se gasta?
```{r,echo=FALSE,  fig.width=5.7,fig.height=4, out.width='90%'}

# Extraer el mes y el día de la fecha
df$mes <- format(df$fecha, "%m")  
df$dia <- format(df$fecha, "%d")  

# Gasto mensual
gasto_mensual <- df %>%
  group_by(mes) %>%
  summarise(gasto_total_mensual = sum(total, na.rm = TRUE)) %>%
  arrange(desc(gasto_total_mensual))

# Graficar gasto total por mes
ggplot(gasto_mensual, aes(x = factor(mes), y = gasto_total_mensual, fill = gasto_total_mensual)) +
  geom_col(show.legend = FALSE) +
  labs(title = "Gasto total por mes",
       x = "Mes (número)",
       y = "Gasto total (€)") +
  scale_fill_gradient(low = "lightgreen", high = "darkgreen") +  
  theme_minimal()

# Gasto diario
gasto_diario <- df %>%
  group_by(dia) %>%
  summarise(gasto_total_diario = sum(total, na.rm = TRUE)) %>%
  arrange(desc(gasto_total_diario))

# Graficar gasto total por día
ggplot(gasto_diario, aes(x = factor(dia), y = gasto_total_diario, fill = gasto_total_diario)) +
  geom_col(show.legend = FALSE) +
  labs(title = "Gasto total por día",
       x = "Día (número)",
       y = "Gasto total (€)") +
  scale_fill_gradient(low = "lightblue", high = "darkblue") + 
  theme_minimal()

```
El mes con más gasto es el mes 01 con un total de 2663.99€.
El día con más gasto es el día 27 con un total de 1005.7€.

## -¿Cuál es las categoría de productos con mayor venta en términos de cantidad, y cuál es su contribución porcentual al total de unidades vendidas? Hay relación entre otras categorías?
```{r, echo=FALSE,  fig.width=5.7,fig.height=4, out.width='90%'}

# Calcular total de unidades vendidas por categoría (tipo de producto)
ventas_por_tipo <- df_final %>% 
  filter(!is.na(tipo)) %>%  
  group_by(tipo) %>%
  summarise(total_unidades = sum(cantidad, na.rm = TRUE)) %>%
  arrange(desc(total_unidades))  

total_unidades_filtrado <- sum(ventas_por_tipo$total_unidades)

ventas_por_tipo <- ventas_por_tipo %>% 
  mutate(porcentaje = round((total_unidades / total_unidades_filtrado) * 100, 2))

ggplot(ventas_por_tipo, aes(x = reorder(tipo, total_unidades), y = total_unidades, fill = tipo)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
  geom_text(aes(label = paste(total_unidades, "(", porcentaje, "%)")), vjust = -0.5) +
  labs(title = "Unidades Vendidas por Categoría", x = "Categoría", y = "Total de Unidades Vendidas") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  

```

# Conclusiones

A través del análisis detallado de los tickets de compra, se han obtenido importantes hallazgos sobre los patrones de consumo en los distintos establecimientos. Hemos identificado qué productos son los más y menos vendidos, tanto por unidades como por kilos, así como aquellos que generan mayor ingreso. También se han detectado diferencias de precios del mismo producto entre tiendas, lo que podría deberse a políticas de precios locales o promociones específicas.

El estudio de los tickets ha permitido observar variaciones en el comportamiento de compra a lo largo de la semana, el mes y el día, identificando los momentos de mayor y menor actividad. Esto puede ser útil para tomar decisiones operativas, como optimizar horarios de apertura o reforzar personal en momentos clave. Además, se han detectado combinaciones frecuentes de productos, lo que aporta pistas sobre los hábitos alimenticios de los clientes, reflejando un patrón de consumo alineado con una dieta mediterránea basada en frutas, verduras y pescado.

En conjunto, estos análisis ofrecen una base sólida para tomar decisiones estratégicas orientadas a mejorar la eficiencia, ajustar la oferta de productos y potenciar la rentabilidad de cada tienda.

