---
title: "ProyectoTD2025"
author: "Mar Alemany, Martín González, Mateo Reina, Sina Taheri, Adrian Mena, Sergio Nadal"
date: "2025-03-28"
output: 
  rticles::mdpi_article:
    extra_dependencies: ["booktabs", "longtable"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# 1. Introducción

En la actualidad, la digitalización de los tickets de compra se ha convertido en una práctica común en grandes cadenas de supermercados. Estos tickets electrónicos, enviados en formato PDF al correo del cliente, no solo reducen el uso de papel, sino que también generan datos valiosos que pueden ser analizados para obtener información relevante sobre los hábitos de consumo, la evolución de precios y las preferencias de los compradores.

Este proyecto tiene como objetivo desarrollar un sistema de análisis automatizado que permita extraer, procesar y visualizar la información contenida en los tickets de Mercadona. Mediante técnicas de tratamiento de datos en R, exploraremos patrones de compra, identificaremos los productos más vendidos, analizaremos la evolución temporal de los precios y determinaremos tendencias en función de la ubicación de la tienda y el momento de la compra.

# 2. Material y Métodos

Para llevar a cabo este proyecto se han seleccionando un conjunto de librerías específicas que respondieran a los distintos requerimientos del análisis. 

Para la manipulación de datos se emplearon los paquetes tidyverse (incluyendo dplyr y stringr), que permitieron realizar operaciones de filtrado, transformación y procesamiento de texto de manera eficiente. La extracción del contenido textual desde los archivos PDF se realizó mediante el paquete pdftools, capaz de preservar la estructura original de los documentos.

Las visualizaciones se generaron utilizando ggplot2, seleccionado por su versatilidad para crear gráficos de alta calidad. Para la presentación de resultados en formatos reproducibles se implementó knitr, facilitando la integración de código, resultados y texto explicativo.

Utilizaremos dos data frames para manejar los datos de manera más eficiente. El primer data frame contendrá la información general del ticket, como la dirección del supermercado, la fecha y hora de la compra, el monto total, entre otros. En este caso, todos los productos registrados en el ticket se almacenarán como una sola cadena de texto en una única variable. El segundo data frame desglosará los productos en variables separadas

Ambos data frames estarán vinculados a través de la variable fs (factura simplificada).


```{r include=FALSE}
#Nos aseguramos de que no haya nada cargado en el Environment
rm(list=ls())

# Especificamos las librerías necesarias en esta lista
packages = c("knitr","tidyverse", "ggplot2", "dplyr", "pdftools", "stringr", "corrplot")
# Cargar los paquetes, sino están intalados, se instalarán automáticamente y serán cargados
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos='http://cran.rediris.es')
    library(x, character.only = TRUE)
  }
})
```

# 3. Importación de los datos
## 3.1 Carga de ficheros

Para evitar errores durante el procesamiento posterior, se realizó un cambio en los nombres de los archivos PDF originales. Los archivos fueron renombrados de forma secuencial con un formato estándar. Esta acción se llevó a cabo una única vez, y por ello el código correspondiente fue comentado en el script, con el fin de prevenir que los archivos se sobrescriban accidentalmente al ejecutar el programa más de una vez.

```{r, include=FALSE}
#Obtener lista de archivos PDF en la carpeta
#archivos <- list.files(path =  "./data" , pattern = "\\.pdf$", full.names = #FALSE, ignore.case = TRUE)

# Renombrar archivos secuencialmente
#for (i in seq_along(archivos)) {
#  nombre_actual <- file.path(ruta_carpeta, archivos[i])
#  extension <- file_ext(archivos[i])
#  nombre_nuevo <- file.path(ruta_carpeta, paste0("M", i, ".", extension))
  
#  file.rename(from = nombre_actual, to = nombre_nuevo)
#}
```

Se procedió a cargar automáticamente todos los archivos PDF contenidos en la carpeta de trabajo designada. Para ello, se empleó una función que permite listar únicamente los archivos con extensión .pdf, garantizando así que solo se consideren los documentos relevantes para el análisis. Esta carga automatizada facilita el procesamiento por lotes y evita la necesidad de seleccionar manualmente cada archivo.
```{r, include=FALSE}
# Obtener lista de archivos PDF en la carpeta
archivos <- list.files(path =  "./data" , pattern = "\\.pdf$", full.names = TRUE, ignore.case = TRUE)
#print(archivos)

n_archivos <- length(archivos)

```

Para el proyecto se han importado un total de `r n_archivos` archivos.

## 3.2 Carga de datos

Se construyó un data frame a partir de los datos extraídos, realizando las transformaciones necesarias para asegurar que cada variable tuviera el formato y tipo de dato adecuados.

Para la lectura de los archivos PDF se utilizaron funciones de la librería pdftools, mientras que la limpieza y manipulación de las cadenas de texto se llevó a cabo con funciones de la librería stringr.

Durante el procesamiento, se asignó el tipo de dato Date a la variable de fecha y se convirtieron en valores numéricos las variables decimales como el total de la compra, la base imponible y la cuota de IVA. Cabe señalar que muchos de los datos no pueden incorporarse directamente al data frame, ya que en el formato original aparecen combinados en una misma línea. Es el caso de la fecha, la hora y el número de operación, que debieron separarse y asignarse a variables distintas.

Por motivos de espacio y legibilidad, no se incluye la visualización del data frame generado a partir de los tickets.

```{r tabla-variables}
type <- c("comercio","empresa", "direccion", "cp", "telefono", "fecha", "hora", "op", "fs", "productos", "total", "forma_pago", "base_imp", "cuota", "nombre del comercio", "tipo y código de empresa", "dirección del comercio", "código postal", "teléfono del comercio", "fecha de la compra (día-mes-año)", "hora de la compra (horas y minutos)", "número del código de la operación", "código de la factura simplificada", "lista con los productos comprados", "dinero total de la compra", "forma de pago (tarjeta o en efectivo)", "base imponible (IVA)", "cuota del IVA")
knitr::kable(rticles::string_to_table(type, 2),align = 'c', 
             col.names = c("Variable", "Descripción"),
             format = "latex", booktab = TRUE, 
             caption = "Descripción de variables") 
```
Las variables finales obtenidas se presentan en la Tabla \@ref(tab:tabla-variables).


```{r, echo = FALSE}
comercio <- c() #nombre del comercio
empresa <- c() #tipo y código de empresa
direccion <- c() 
cp <- c() #código postal
telefono <- c() #Misma línea, tendremos que separar estos valores
fecha <- c()
hora <- c()
op <- c()
fs <- c()#factura
productos <- c() #lista con los productos comprados
total <- c() #total de la compra
forma_pago <- c()

#IVA
base_imp <- c() #Base imponible
cuota <- c() #Cuota 

```


```{r, echo = FALSE}
for (archivo in archivos) {
  
  pdf <- pdf_text(archivo) #leemos le archivo pdf
  ticket <- trimws(strsplit(pdf,split = "\n")[[1]]) #separamos por líneas
  ticket <- ticket[grep(".", ticket)] #quitamos las líneas vacías

  #procesamos los datos del ticket
  linea_comercio <- ticket[1]
  linea_direccion <- ticket[2]
  linea_cp <- ticket[3]
  linea_telefono <- ticket[4]
  linea_fecha_hora_op <- ticket[5]
  linea_fs <- ticket[6]
  p = 8 
  linea_productos <- ticket[p]
    #unimos todos los productos en un solo caracter
  while (ticket[p+1] != ticket[grep("TOTAL", ticket)[1]]){
    p = p + 1
    linea_productos <- paste(linea_productos, ticket[p],sep = ";")
  }
  linea_total <- ticket[grep("TOTAL", ticket)[1]]
  linea_forma_pago <- ticket[p+2]
  linea_iva <- ticket[grep("TOTAL", ticket)[2]]
  
  #extraemos los datos
  com <- strsplit(linea_comercio,", ")[[1]]
  comercio <- c(comercio, com[1])
  empresa <- c(empresa, com[2])
  direccion <- c(direccion, trimws(linea_direccion))
  cp_info <- strsplit(trimws(linea_cp), " ")[[1]]
  cp <- c(cp, cp_info[1])
  telefono <- c(telefono, trimws(gsub("TELÉFONO:", "", linea_telefono)))
  fecha_hora_op <- strsplit(trimws(linea_fecha_hora_op), " ")[[1]]
  fecha_hora_op <- fecha_hora_op[grep(".", fecha_hora_op)]
  fecha <- c(fecha, fecha_hora_op[1])
  hora <- c(hora, fecha_hora_op[2])
  op <- c(op, gsub("OP:", "", fecha_hora_op[4]))
  fs <- c(fs, gsub("FACTURA SIMPLIFICADA:", "", linea_fs))
  productos <- c(productos, linea_productos)
  total <- c(total, trimws(gsub("TOTAL [(]€[)]", "", linea_total)))
  formapago <- strsplit(linea_forma_pago," ")[[1]]
  forma_pago <- c(forma_pago, paste0(formapago[1],formapago[2]))
  base_couta <- strsplit(trimws(linea_iva),split = " ")[[1]]
  base_couta <- base_couta[grep(".", base_couta)]
  base_imp <- c(base_imp,base_couta[2])
  cuota <- c(cuota, base_couta[3])
  
}
```


```{r, echo = FALSE}
df <- data.frame(comercio, empresa, direccion, cp, telefono, fecha, hora, 
                 op, fs, productos, total, forma_pago, base_imp, cuota,
                 stringsAsFactors = FALSE)

#Modificamos las clases de los datos
df$fecha <- as.Date(df$fecha,format = "%d/%m/%Y")
df$anio <- as.numeric(format(df$fecha, "%Y"))
df$mes <- as.numeric(format(df$fecha, "%m"))
df$dia <- as.numeric(format(df$fecha, "%d"))
# Elimina la columna fecha
df$fecha <- NULL

# Separar la columna fs en tres partes
fs_split <- strsplit(df$fs, "-")
# Crear las nuevas columnas a partir del resultado
df$num_tienda <- sapply(fs_split, function(x) x[1])
df$num_caja <- sapply(fs_split, function(x) x[2])
df$num_ticket <- sapply(fs_split, function(x) x[3])
# Eliminar la columna original fs
df$fs <- NULL
df$comercio <- NULL
df$empresa <- NULL


df$total <- as.numeric(gsub(pattern = ",",replacement = ".",df$total))
df$base_imp <- as.numeric(gsub(pattern = ",",replacement = ".",df$base_imp))
df$cuota <- as.numeric(gsub(pattern = ",",replacement = ".",df$cuota))
```

```{r, echo = FALSE}
aparcamientos <- c()
for (archivo in archivos) {
  pdf <- pdf_text(archivo)
  ticket <- trimws(strsplit(pdf, split = "\n")[[1]])
  aparcamiento_lineas <- grep("Aparcamiento", ticket, value = TRUE)
  if (length(aparcamiento_lineas) > 0) {
    aparcamientos <- c(aparcamientos, paste(aparcamiento_lineas, collapse = " "))
  } else {
    aparcamientos <- c(aparcamientos, NA)
  }
}
df_aparcamiento <- data.frame(archivo = archivos, aparcamiento = aparcamientos, stringsAsFactors = FALSE)
head(df_aparcamiento)

```
# 4. Analizamos los productos

La información relativa a los productos comprados se encontraba inicialmente agrupada dentro de una única columna del data frame principal. Para facilitar su análisis, se extrajo esta columna a un nuevo data frame, separando los productos que venían concatenados en una misma celda.

## 4.1 Productos pescateria
El procesamiento de los productos se realizó en varias etapas, según el tipo de producto y la forma en que aparecían en el ticket. En primer lugar, se identificaron los productos de pescadería, que siguen un formato particular: aparecen siempre precedidos por una línea con la palabra "PESCADO", seguida del nombre del producto en la línea siguiente y de los detalles de compra (peso, precio por kilo y total) en una tercera línea. A partir de esta estructura, se extrajeron los datos relevantes y se almacenaron en un nuevo data frame específico para pescado.


## 4.2 Productos vendidos por peso

Después, se eliminaron las filas correspondientes a productos de pescadería para poder trabajar exclusivamente con los productos que también se venden por peso, como frutas y verduras. Estos artículos generalmente constan de dos líneas: la primera contiene el nombre del producto y la segunda incluye el peso, el precio por kilogramo y el importe total. A partir de esta estructura se construyó un segundo data frame con las frutas y verduras, extrayendo y transformando la información necesaria.

## 4.2 Productos vendidos por unidad

Una vez separados los productos por peso, se procedió a procesar el resto de productos, es decir, aquellos que se venden por unidades. En este caso, se extrajeron datos como la cantidad, el nombre del producto, el precio unitario y el importe total. Se aplicaron técnicas de procesamiento de texto para limpiar y estructurar la información, ya que algunos productos con una sola unidad incluían el precio directamente dentro del nombre del producto.

# 4.4 productos analizados
Finalmente, los tres grupos de productos —pescado, frutas y verduras, y productos por unidades— se combinaron en un único data frame unificado. A este conjunto se le añadió una columna adicional que indicaba si el ticket incluía un servicio de aparcamiento, en caso de que esa información estuviera disponible. El resultado fue un data frame final, estructurado y homogéneo, con todos los productos organizados por tipo, cantidad, precio, importe y número de ticket, listo para su análisis posterior.


```{r}
df_producto <- df %>% select(c(num_ticket, productos)) %>% 
  separate_rows(productos, sep = ";")
```


```{r}
# Procesamiento de pescado por kg

# Identificar filas con "PESCADO"
filas_pescado <- which(df_producto$productos == "PESCADO")

# Inicializar vectores para almacenar datos
num_ticket_vec <- character()
nombre_producto_vec <- character()
peso_kg_vec <- numeric()
precio_kg_vec <- numeric()
precio_total_vec <- numeric()

for (i in seq_along(filas_pescado)) {
  idx <- filas_pescado[i]
  
  # Extraer información básica
  num_ticket <- df_producto$num_ticket[idx]
  nombre <- df_producto$productos[idx + 1]  # Nombre en la siguiente fila
  
  # Procesar la fila de detalles
  detalles <- df_producto$productos[idx + 2]
  
  # Limpiar y dividir la cadena de detalles
  detalles_limpio <- gsub(",", ".", detalles)  # Reemplazar comas por puntos
  detalles_split <- strsplit(trimws(detalles_limpio), "\\s+")[[1]]
  
  # Extraer valores (asumiendo orden: peso, unidad, precio_kg, moneda, precio_total)
  if (length(detalles_split) >= 5) {
    peso_kg <- as.numeric(detalles_split[1])
    precio_kg <- as.numeric(detalles_split[3])
    importe <- as.numeric(detalles_split[5])
    
    # Almacenar en vectores
    num_ticket_vec <- c(num_ticket_vec, num_ticket)
    nombre_producto_vec <- c(nombre_producto_vec, nombre)
    peso_kg_vec <- c(peso_kg_vec, peso_kg)
    precio_kg_vec <- c(precio_kg_vec, precio_kg)
    precio_total_vec <- c(precio_total_vec, importe)
  }
}

df_pescado <- data.frame(
  num_ticket = num_ticket_vec,
  nombre = nombre_producto_vec,
  peso_kg = peso_kg_vec,
  precio_kg = precio_kg_vec,
  importe = precio_total_vec,
  stringsAsFactors = FALSE
)

```

```{r}
# Procesamiento fruta y la verdura

#Identificar TODOS los bloques de pescado (3 filas cada uno)
bloques_pescado <- which(df_producto$productos == "PESCADO")

# Crear vector con TODAS las filas a eliminar (cada bloque son 3 filas)
filas_a_eliminar <- unlist(lapply(bloques_pescado, function(x) x:(x+2)))

# Eliminar todos los bloques
df_sin_pescado <- df_producto[-filas_a_eliminar, ]

ind_detalles_kg <- grep("kg.*€/kg", df_sin_pescado$productos, value = FALSE)

df_fruta_verdura <- data.frame(
  num_ticket = df_sin_pescado$num_ticket[ind_detalles_kg],
  nombre = df_sin_pescado$productos[ind_detalles_kg - 1],
  detalles = df_sin_pescado$productos[ind_detalles_kg],
  stringsAsFactors = FALSE
) %>%
mutate(
  # Limpiar el nombre (eliminar números iniciales)
  nombre = gsub("^\\d+\\s*", "", nombre),
  
  # Extraer peso (kg) - primer número en la línea
  peso_kg = as.numeric(gsub(",", ".", str_extract(detalles, "^[0-9,]+"))),
  
  # Extraer precio por kg - método mejorado
  precio_kg = as.numeric(gsub(",", ".", 
    str_extract(detalles, "[0-9,]+(?=\\s*€/kg)"))),
  
  # Extraer importe total - último número en la línea
  importe = as.numeric(gsub(",", ".", 
    str_extract(detalles, "[0-9,]+$")))
) %>%
select(-detalles)

```


```{r}
# Procesamiento resto de productos sin kg

# Identificar las filas de detalles (kg y €/kg)
ind_detalles_kg <- grep("kg.*€/kg", df_sin_pescado$productos, value = FALSE)

# Las filas de nombres están justo antes de los detalles
ind_nombres_kg <- ind_detalles_kg - 1

# Combinar todos los índices a eliminar
filas_fruta_verdura <- sort(unique(c(ind_nombres_kg, ind_detalles_kg)))

# Eliminar filas ya procesadas
df_resto <- df_sin_pescado[-filas_fruta_verdura, ]

df_productos_unidades <- df_resto %>%
  mutate(
    # 1. Extraer cantidad (siempre es el primer número)
    cantidad = as.numeric(str_extract(productos, "^\\d+")),
    
    # 2. Extraer posible precio en el nombre (para productos de 1 unidad)
    precio_en_nombre = ifelse(cantidad == 1,
                            as.numeric(gsub(",", ".", str_extract(productos, "\\d+,\\d+$"))),
                            NA_real_),
    
    # 3. Procesamiento vectorizado de componentes
    componentes = strsplit(productos, "\\s+"),
    
    # 4. Extraer importe normal (para productos con múltiples unidades)
    importe_normal = sapply(componentes, function(x) {
      if(length(x) >= 3) as.numeric(gsub(",", ".", x[length(x)])) else NA_real_
    }),
    
    # 5. Determinar el importe final
    importe = ifelse(!is.na(precio_en_nombre), precio_en_nombre, importe_normal),
    
    # 6. Extraer descripción limpia (MODIFICACIÓN CLAVE)
    nombre = mapply(function(comp, prod, cant, precio_nombre) {
      # Primero eliminar la cantidad inicial (si existe)
      nombre_limpio <- gsub("^\\d+\\s*", "", prod)
      
      if(length(comp) <= 2) return(nombre_limpio)  # Caso simple
      
      if(!is.na(precio_nombre)) {
        # Para productos de 1 unidad: eliminar precio final
        gsub("\\s+\\d+,\\d+$", "", nombre_limpio)
      } else {
        # Para múltiples unidades: eliminar elementos numéricos finales
        paste(comp[2:(length(comp)-2)], collapse=" ")
      }
    }, componentes, productos, cantidad, precio_en_nombre, SIMPLIFY = TRUE) %>%
      str_trim()  # Eliminar espacios sobrantes
  ) %>%
  mutate(
    # 7. Calcular precio unitario
    precio_unitario = importe / cantidad
  ) %>%
  select(num_ticket, nombre, cantidad, precio_unitario, importe)
```


```{r}
# dataframe final con todos los productos analizados:

# Añadir columna 'tipo' a cada dataframe
df_pescado <- df_pescado %>% mutate(tipo = "pescado")
df_fruta_verdura <- df_fruta_verdura %>% mutate(tipo = "fruta_verdura")
df_productos_unidades <- df_productos_unidades %>% mutate(tipo = "unidades")

# Unificar columnas para combinar
df_final <- bind_rows(
  df_pescado %>% select(num_ticket, nombre, cantidad = peso_kg, precio = precio_kg, importe, tipo),
  df_fruta_verdura %>% select(num_ticket, nombre, cantidad = peso_kg, precio = precio_kg, importe, tipo),
  df_productos_unidades %>% select(num_ticket, nombre = nombre, cantidad, precio = precio_unitario, importe, tipo)
)

# Crear columna tiene_aparcamiento 
if ("aparcamiento" %in% colnames(df_aparcamiento)) {
  df_aparcamiento <- df_aparcamiento %>%
    mutate(nombre_archivo = basename(archivo)) %>%
    mutate(num_ticket = str_extract(nombre_archivo, "\\d+")) %>%
    mutate(tiene_aparcamiento = !is.na(aparcamiento)) %>%
    select(num_ticket, tiene_aparcamiento)

  # Convertir num_ticket a carácter en ambos dataframes
  df_final <- df_final %>% mutate(num_ticket = as.character(num_ticket))
  df_aparcamiento <- df_aparcamiento %>% mutate(num_ticket = as.character(num_ticket))

  # Combinar los datos
  df_final <- left_join(df_final, df_aparcamiento, by = "num_ticket")
} else {
  df_final$tiene_aparcamiento <- NA  # columna vacía si no existe 'aparcamiento'
}

# Resultado final ordenado
df_final <- df_final %>% arrange(num_ticket)

# Verificación final
cat("\nResumen del DataFrame final:\n")
cat("- Pescado:", sum(df_final$tipo == "pescado"), "registros\n")
cat("- Fruta/Verdura:", sum(df_final$tipo == "fruta_verdura"), "registros\n")
cat("- Unidades:", sum(df_final$tipo == "unidades"), "registros\n")
cat("- Total:", nrow(df_final), "registros\n")

print(head(df_final, 10))


```

#Preguntas

1- ¿Cuáles son los productos menos vendidos por unidades? ¿Y por kilos?
```{r}

unidades <- df_final[df_final$tipo == "unidades", ]
unidades_agrupadas <- aggregate(cantidad ~ nombre, data = unidades, sum)
unidades_ordenadas <- unidades_agrupadas[order(unidades_agrupadas$cantidad), ]

head(unidades_ordenadas, n = 3)
```

```{r}
kilos <- df_final[df_final$tipo == "fruta_verdura", ]
kilos_agrupados <- aggregate(cantidad ~ nombre, data = kilos, sum)
kilos_ordenados <- kilos_agrupados[order(kilos_agrupados$cantidad), ]
head(kilos_ordenados, n = 3)

```
Respuesta: El producto menos vendido por unidades son PROTEÍNAS CAFÉ, 1/2 POLLO PARTIDO	y 12 HUEVOS MEDIANOS-M.
Y el producto menos vendido por kilo es Pera Rocha con 0.364kg

2-¿Qué productos han generado mayor ingreso total (precio x cantidad)?
```{r}
# Calcular ingreso total por producto (importe = precio × cantidad)
df_final$ingreso_total <- df_final$precio * df_final$cantidad

# Ordenar por ingreso total descendente
productos_ordenados <- df_final[order(-df_final$ingreso_total), ]

# Mostrar los productos con mayor ingreso total

print(productos_ordenados[, c("nombre", "ingreso_total")])

# Top 3 productos con mayor ingreso total

print(head(productos_ordenados[, c("nombre", "ingreso_total")], 3))

```
Respuesta: Como vemos Alistado Mediano con 31.33 es mayor

3-¿Cuáles productos han aumentado o disminuido su venta a lo largo del tiempo?

4-¿Qué productos se compran habitualmente juntos? 
```{r}
library(arules)
library(arulesViz)

#Preparar los datos en formato transaccional
transacciones <- as(split(df_final$nombre, df_final$num_ticket), "transactions")

#Aplicar el algoritmo Apriori para encontrar reglas de asociación
reglas <- apriori(transacciones, parameter = list(support = 0.01, confidence = 0.5, minlen = 2))

# Filtrar y ordenar las reglas más interesantes
reglas_interesantes <- subset(reglas, lift > 1)
inspect(sort(reglas_interesantes, by = "lift"))

#  Visualización
plot(reglas_interesantes, method = "graph", engine = "htmlwidget")

```
Respuesta: Esta pregunta es muy general y esta funcionalidad puede mostrar qué productos se compran juntos con más frecuencia.


5-¿Existen diferencias de precios para el mismo producto en diferentes tiendas o ubicaciones?
```{r}
library(dplyr)
df_final %>%
  group_by(nombre,precio) %>%
  summarise(df$direccion) -> diferencias_precio
print(diferencias precio)
```
6-¿Qué días de la semana hay más ventas? ¿Y a qué horas?


7-En qué meses se venden más frutas/verduras, o pescados?


8-¿Desde qué ciudades se emiten más tickets?
df %>%
  group_by(direccion) %>%
  summarise(n_tickets = n_distinct(num_ticket)) %>%
  arrange(desc(n_ticket)) <- tickets_por_mercadona
print(tickets_por_mercadona)
# Se emiten mas tickets desde el mercadona de "C/Quart 120"

9-¿Existen diferencias de consumo por cada mercadona?
df%>%
  group_by(direccion)
  summarise(
    media_gasto=mean(total, na.rm = TRUE)
    mediana_gasto=median(total,  na.rm = TRUE)
    desv_gasto=sd(total, na.rm = TRUE)
  ) %>%
  arrange(desc(media_gasto)) <- gasto_por_mercadona
print(gasto_por_mercadona)
# Si que hay diferencia de consumo, en cada mercadona la media de consumo es difernete, el mercadona con la media de consumo mas alto es "Avda. del textil 21"


10-¿Que mes y que dia del año es cuando mas dinero se gasta?
# Gasto mensual
gasto_mensual <- df %>%
  group_by(mes) %>%
  summarise(gasto_total_mensual = sum(total, na.rm = TRUE)) %>%
  arrange(desc(gasto_total_mensual))

print(gasto_mensual)
# El mes del año con mas gasto es enero, seguido de marzo y febrero

ggplot(gasto_mensual, aes(x = factor(mes), y = gasto_total_mensual, fill = factor(mes))) +
  geom_col(show.legend = FALSE) +
  labs(title = "Gasto total por mes",
       x = "Mes (número)",
       y = "Gasto total") +
  theme_minimal()


# Gasto diario
gasto_diario <- df %>%
  group_by(dia) %>%
  summarise(gasto_total_diario = sum(total, na.rm = TRUE)) %>%
  arrange(desc(gasto_total_diario))

print(gasto_diario)
# El dia del mes con más gasto es el dia 27 de cada mes 

ggplot(gasto_diario, aes(x = factor(dia), y = gasto_total_diario, fill = factor(dia))) +
  geom_col(show.legend = FALSE) +
  labs(title = "Gasto total por dia",
       x = "Dia (número)",
       y = "Gasto total") +
  theme_minimal()

11-¿Influye la disponibilidad de aparcamiento en el importe total de la compra?
```{r}
resultados <- df_final %>% filter(!is.na(tiene_aparcamiento)) %>% group_by(tiene_aparcamiento) %>%
summarise(
    n_compras = n(),
    media_total = mean(total, na.rm = TRUE),
    mediana_total = median(total, na.rm = TRUE),
    sd_total = sd(total, na.rm = TRUE),
    min_total = min(total, na.rm = TRUE),
    max_total = max(total, na.rm = TRUE)
  ) %>% arrange(desc(media_total))


print(resultados) 



```
Respuesta: No hay datos de aparcamiento, pués no influye.
