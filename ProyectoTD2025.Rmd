---
title: "ProyectoTD2025"
author: "Mar Alemany, Martín González, Mateo Reina, Sina Taheri, Adrian Mena, Sergio Nadal"
date: "2025-03-28"
output: 
  rticles::mdpi_article:
    extra_dependencies: ["booktabs", "longtable"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Introducción

En la actualidad, la digitalización de los tickets de compra se ha convertido en una práctica común en grandes cadenas de supermercados. Estos tickets electrónicos, enviados en formato PDF al correo del cliente, no solo reducen el uso de papel, sino que también generan datos valiosos que pueden ser analizados para obtener información relevante sobre los hábitos de consumo, la evolución de precios y las preferencias de los compradores.

Este proyecto tiene como objetivo desarrollar un sistema de análisis automatizado que permita extraer, procesar y visualizar la información contenida en los tickets de Mercadona. Mediante técnicas de tratamiento de datos en R, exploraremos patrones de compra, identificaremos los productos más vendidos, analizaremos la evolución temporal de los precios y determinaremos tendencias en función de la ubicación de la tienda y el momento de la compra.

# Material y Métodos

Para llevar a cabo este proyecto se han seleccionando un conjunto de librerías específicas que respondieran a los distintos requerimientos del análisis. 

Para la manipulación de datos se emplearon los paquetes tidyverse (incluyendo dplyr y stringr), que permitieron realizar operaciones de filtrado, transformación y procesamiento de texto de manera eficiente. La extracción del contenido textual desde los archivos PDF se realizó mediante el paquete pdftools, capaz de preservar la estructura original de los documentos.

Las visualizaciones se generaron utilizando ggplot2, seleccionado por su versatilidad para crear gráficos de alta calidad. Para la presentación de resultados en formatos reproducibles se implementó knitr, facilitando la integración de código, resultados y texto explicativo.

Utilizaremos dos data frames para manejar los datos de manera más eficiente. El primer data frame contendrá la información general del ticket, como la dirección del supermercado, la fecha y hora de la compra, el monto total, entre otros. En este caso, todos los productos registrados en el ticket se almacenarán como una sola cadena de texto en una única variable. El segundo data frame desglosará los productos en variables separadas

Ambos data frames estarán vinculados a través de la variable fs (factura simplificada).

```{r, include=FALSE}
#Nos aseguramos de que no haya nada cargado en el Environment
rm(list=ls())

# Especificamos las librerías necesarias en esta lista
packages = c("knitr","tidyverse", "ggplot2", "dplyr", "pdftools", "stringr", "corrplot")
# Cargar los paquetes, sino están intalados, se instalarán automáticamente y serán cargados
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos='http://cran.rediris.es')
    library(x, character.only = TRUE)
  }
})
```

# Importación de los datos
## Carga de ficheros

Para evitar errores durante el procesamiento posterior, se realizó un cambio en los nombres de los archivos PDF originales. Los archivos fueron renombrados de forma secuencial con un formato estándar. Esta acción se llevó a cabo una única vez, y por ello el código correspondiente fue comentado en el script, con el fin de prevenir que los archivos se sobrescriban accidentalmente al ejecutar el programa más de una vez.

```{r, include=FALSE}
#Obtener lista de archivos PDF en la carpeta
#archivos <- list.files(path =  "./data" , pattern = "\\.pdf$", full.names = #FALSE, ignore.case = TRUE)

# Renombrar archivos secuencialmente
#for (i in seq_along(archivos)) {
#  nombre_actual <- file.path(ruta_carpeta, archivos[i])
#  extension <- file_ext(archivos[i])
#  nombre_nuevo <- file.path(ruta_carpeta, paste0("M", i, ".", extension))
  
#  file.rename(from = nombre_actual, to = nombre_nuevo)
#}
```

Se procedió a cargar automáticamente todos los archivos PDF contenidos en la carpeta de trabajo designada. Para ello, se empleó una función que permite listar únicamente los archivos con extensión .pdf, garantizando así que solo se consideren los documentos relevantes para el análisis. Esta carga automatizada facilita el procesamiento por lotes y evita la necesidad de seleccionar manualmente cada archivo.

```{r, include=FALSE}
# Obtener lista de archivos PDF en la carpeta
archivos <- list.files(path =  "./data" , pattern = "\\.pdf$", full.names = TRUE, ignore.case = TRUE)
#print(archivos)

n_archivos <- length(archivos)

```

Para el proyecto se han importado un total de `r n_archivos` archivos.

## Carga de datos

Se construyó un data frame a partir de los datos extraídos, realizando las transformaciones necesarias para asegurar que cada variable tuviera el formato y tipo de dato adecuados.

Para la lectura de los archivos PDF se utilizaron funciones de la librería pdftools, mientras que la limpieza y manipulación de las cadenas de texto se llevó a cabo con funciones de la librería stringr.

Durante el procesamiento, se asignó el tipo de dato Date a la variable de fecha y se convirtieron en valores numéricos las variables decimales como el total de la compra, la base imponible y la cuota de IVA. Cabe señalar que muchos de los datos no pueden incorporarse directamente al data frame, ya que en el formato original aparecen combinados en una misma línea. Es el caso de la fecha, la hora y el número de operación, que debieron separarse y asignarse a variables distintas.


```{r tabla_variables, echo=FALSE, results='asis'}
vars <- c("comercio", "empresa", "direccion", "cp", "telefono", "fecha", "hora", 
          "op", "fs", "productos", "total", "forma_pago", "base_imp", "cuota")
desc <- c("Nombre del comercio", "Tipo y código de empresa", "Dirección del comercio", 
          "Código postal", "Teléfono del comercio", "Fecha de la compra (día-mes-año)", 
          "Hora de la compra (horas y minutos)", "Número del código de la operación", 
          "Código de la factura simplificada", "Lista con los productos comprados", 
          "Dinero total de la compra", "Forma de pago (tarjeta o en efectivo)", 
          "Base imponible (IVA)", "Cuota del IVA")

tabla <- data.frame(Variable = vars, Descripción = desc)

knitr::kable(tabla, align = 'c', format = "latex", booktabs = TRUE,
             caption = "Descripción de variables")



```

Las variables finales obtenidas se pueden observar en la Tabla \ref{tab:tabla_variables}.

Por razones de espacio y legibilidad, no se muestra en el documento el conjunto de datos (df), ya que contiene un número elevado de observaciones y variables. 


```{r, echo = FALSE}
comercio <- c() #nombre del comercio
empresa <- c() #tipo y código de empresa
direccion <- c() 
cp <- c() #código postal
telefono <- c() #Misma línea, tendremos que separar estos valores
fecha <- c()
hora <- c()
op <- c()
fs <- c()#factura
productos <- c() #lista con los productos comprados
total <- c() #total de la compra
forma_pago <- c()

#IVA
base_imp <- c() #Base imponible
cuota <- c() #Cuota 

```


```{r, include = FALSE}
for (archivo in archivos) {
  
  pdf <- pdf_text(archivo) #leemos le archivo pdf
  ticket <- trimws(strsplit(pdf,split = "\n")[[1]]) #separamos por líneas
  ticket <- ticket[grep(".", ticket)] #quitamos las líneas vacías

  #procesamos los datos del ticket
  linea_comercio <- ticket[1]
  linea_direccion <- ticket[2]
  linea_cp <- ticket[3]
  linea_telefono <- ticket[4]
  linea_fecha_hora_op <- ticket[5]
  linea_fs <- ticket[6]
  p = 8 
  linea_productos <- ticket[p]
    #unimos todos los productos en un solo caracter
  while (ticket[p+1] != ticket[grep("TOTAL", ticket)[1]]){
    p = p + 1
    linea_productos <- paste(linea_productos, ticket[p],sep = ";")
  }
  linea_total <- ticket[grep("TOTAL", ticket)[1]]
  linea_forma_pago <- ticket[p+2]
  linea_iva <- ticket[grep("TOTAL", ticket)[2]]
  
  #extraemos los datos
  com <- strsplit(linea_comercio,", ")[[1]]
  comercio <- c(comercio, com[1])
  empresa <- c(empresa, com[2])
  direccion <- c(direccion, trimws(linea_direccion))
  cp_info <- strsplit(trimws(linea_cp), " ")[[1]]
  cp <- c(cp, cp_info[1])
  telefono <- c(telefono, trimws(gsub("TELÉFONO:", "", linea_telefono)))
  fecha_hora_op <- strsplit(trimws(linea_fecha_hora_op), " ")[[1]]
  fecha_hora_op <- fecha_hora_op[grep(".", fecha_hora_op)]
  fecha <- c(fecha, fecha_hora_op[1])
  hora <- c(hora, fecha_hora_op[2])
  op <- c(op, gsub("OP:", "", fecha_hora_op[4]))
  fs <- c(fs, gsub("FACTURA SIMPLIFICADA:", "", linea_fs))
  productos <- c(productos, linea_productos)
  total <- c(total, trimws(gsub("TOTAL [(]€[)]", "", linea_total)))
  formapago <- strsplit(linea_forma_pago," ")[[1]]
  forma_pago <- c(forma_pago, paste0(formapago[1],formapago[2]))
  base_couta <- strsplit(trimws(linea_iva),split = " ")[[1]]
  base_couta <- base_couta[grep(".", base_couta)]
  base_imp <- c(base_imp,base_couta[2])
  cuota <- c(cuota, base_couta[3])
  
}


```


```{r , include= FALSE}
df <- data.frame(comercio, empresa, direccion, cp, telefono, fecha, hora, 
                 op, fs, productos, total, forma_pago, base_imp, cuota,
                 stringsAsFactors = FALSE)

#Modificamos las clases de los datos
df$fecha <- as.Date(df$fecha,format = "%d/%m/%Y")
df$anio <- as.numeric(format(df$fecha, "%Y"))
df$mes <- as.numeric(format(df$fecha, "%m"))
df$dia <- as.numeric(format(df$fecha, "%d"))
# Elimina la columna fecha
df$fecha <- NULL

# Separar la columna fs en tres partes
fs_split <- strsplit(df$fs, "-")
# Crear las nuevas columnas a partir del resultado
df$num_tienda <- sapply(fs_split, function(x) x[1])
df$num_caja <- sapply(fs_split, function(x) x[2])
df$num_ticket <- sapply(fs_split, function(x) x[3])
# Eliminar la columna original fs
df$fs <- NULL
df$comercio <- NULL
df$empresa <- NULL


df$total <- as.numeric(gsub(pattern = ",",replacement = ".",df$total))
df$base_imp <- as.numeric(gsub(pattern = ",",replacement = ".",df$base_imp))
df$cuota <- as.numeric(gsub(pattern = ",",replacement = ".",df$cuota))
```

```{r tabla_datos, include=FALSE, results='asis'}
# Solo mostramos las primeras 10 filas para que no sea muy larga
knitr::kable(head(df, 10),
             align = 'c',
             format = "latex", booktabs = TRUE, longtable = TRUE,
             caption = "Primeras observaciones del conjunto de datos procesado",
             col.names = c("Dirección", "CP", "Teléfono", "Hora", "Operación", 
                           "Productos", "Total", "Forma de pago", 
                           "Base imponible", "Cuota IVA", "Año", "Mes", "Día", 
                           "Tienda", "Caja", "Ticket"))

```


```{r, include= FALSE}
aparcamientos <- c()
for (archivo in archivos) {
  pdf <- pdf_text(archivo)
  ticket <- trimws(strsplit(pdf, split = "\n")[[1]])
  aparcamiento_lineas <- grep("Aparcamiento", ticket, value = TRUE)
  if (length(aparcamiento_lineas) > 0) {
    aparcamientos <- c(aparcamientos, paste(aparcamiento_lineas, collapse = " "))
  } else {
    aparcamientos <- c(aparcamientos, NA)
  }
}
df_aparcamiento <- data.frame(archivo = archivos, aparcamiento = aparcamientos, stringsAsFactors = FALSE)

```

# Analizamos los productos

La información relativa a los productos comprados se encontraba inicialmente agrupada dentro de una única columna del data frame principal. Para facilitar su análisis, se extrajo esta columna a un nuevo data frame, separando los productos que venían concatenados en una misma celda.

```{r, include=FALSE}
df_producto <- df %>% select(c(num_ticket, productos)) %>% 
  separate_rows(productos, sep = ";")
```


## Productos pescateria

El procesamiento de los productos se realizó en varias etapas, según el tipo de producto y la forma en que aparecían en el ticket. En primer lugar, se identificaron los productos de pescadería, que siguen un formato particular: aparecen siempre precedidos por una línea con la palabra "PESCADO", seguida del nombre del producto en la línea siguiente y de los detalles de compra (peso, precio por kilo y total) en una tercera línea. A partir de esta estructura, se extrajeron los datos relevantes y se almacenaron en un nuevo data frame específico para pescado.


```{r, include=FALSE}
# Procesamiento de pescado por kg

# Identificar filas con "PESCADO"
filas_pescado <- which(df_producto$productos == "PESCADO")

# Inicializar vectores para almacenar datos
num_ticket_vec <- character()
nombre_producto_vec <- character()
peso_kg_vec <- numeric()
precio_kg_vec <- numeric()
precio_total_vec <- numeric()

for (i in seq_along(filas_pescado)) {
  idx <- filas_pescado[i]
  
  # Extraer información básica
  num_ticket <- df_producto$num_ticket[idx]
  nombre <- df_producto$productos[idx + 1]  # Nombre en la siguiente fila
  
  # Procesar la fila de detalles
  detalles <- df_producto$productos[idx + 2]
  
  # Limpiar y dividir la cadena de detalles
  detalles_limpio <- gsub(",", ".", detalles)  # Reemplazar comas por puntos
  detalles_split <- strsplit(trimws(detalles_limpio), "\\s+")[[1]]
  
  # Extraer valores (asumiendo orden: peso, unidad, precio_kg, moneda, precio_total)
  if (length(detalles_split) >= 5) {
    peso_kg <- as.numeric(detalles_split[1])
    precio_kg <- as.numeric(detalles_split[3])
    importe <- as.numeric(detalles_split[5])
    
    # Almacenar en vectores
    num_ticket_vec <- c(num_ticket_vec, num_ticket)
    nombre_producto_vec <- c(nombre_producto_vec, nombre)
    peso_kg_vec <- c(peso_kg_vec, peso_kg)
    precio_kg_vec <- c(precio_kg_vec, precio_kg)
    precio_total_vec <- c(precio_total_vec, importe)
  }
}

df_pescado <- data.frame(
  num_ticket = num_ticket_vec,
  nombre = nombre_producto_vec,
  peso_kg = peso_kg_vec,
  precio_kg = precio_kg_vec,
  importe = precio_total_vec,
  stringsAsFactors = FALSE
)

```

```{r tabla_pescado, echo =FALSE, results='asis'}
# Mostrar el dataframe df_pescado en formato tabla
knitr::kable(head(df_pescado, 10), align = 'c', format = "latex", booktabs = TRUE,
             caption = "Datos procesados para productos de pescadería")

```

En la siguiente tabla \ref{tab:tabla_pescado} se pueden observar los datos procesados para los productos de pescadería .

## Productos vendidos por peso

Después, se eliminaron las filas correspondientes a productos de pescadería para poder trabajar exclusivamente con los productos que también se venden por peso, como frutas y verduras. Estos artículos generalmente constan de dos líneas: la primera contiene el nombre del producto y la segunda incluye el peso, el precio por kilogramo y el importe total. A partir de esta estructura se construyó un segundo data frame con las frutas y verduras, extrayendo y transformando la información necesaria.


```{r, include= FALSE}
# Procesamiento fruta y la verdura

#Identificar TODOS los bloques de pescado (3 filas cada uno)
bloques_pescado <- which(df_producto$productos == "PESCADO")

# Crear vector con TODAS las filas a eliminar (cada bloque son 3 filas)
filas_a_eliminar <- unlist(lapply(bloques_pescado, function(x) x:(x+2)))

# Eliminar todos los bloques
df_sin_pescado <- df_producto[-filas_a_eliminar, ]

ind_detalles_kg <- grep("kg.*€/kg", df_sin_pescado$productos, value = FALSE)

df_fruta_verdura <- data.frame(
  num_ticket = df_sin_pescado$num_ticket[ind_detalles_kg],
  nombre = df_sin_pescado$productos[ind_detalles_kg - 1],
  detalles = df_sin_pescado$productos[ind_detalles_kg],
  stringsAsFactors = FALSE
) %>%
mutate(
  # Limpiar el nombre (eliminar números iniciales)
  nombre = gsub("^\\d+\\s*", "", nombre),
  
  # Extraer peso (kg) - primer número en la línea
  peso_kg = as.numeric(gsub(",", ".", str_extract(detalles, "^[0-9,]+"))),
  
  # Extraer precio por kg - método mejorado
  precio_kg = as.numeric(gsub(",", ".", 
    str_extract(detalles, "[0-9,]+(?=\\s*€/kg)"))),
  
  # Extraer importe total - último número en la línea
  importe = as.numeric(gsub(",", ".", 
    str_extract(detalles, "[0-9,]+$")))
) %>%
select(-detalles)

```

```{r tabla_fruta_verdura, echo=FALSE, results='asis'}
knitr::kable(head(df_fruta_verdura, 10), align = 'c', format = "latex", booktabs = TRUE,
             caption = "Descripción de variables del conjunto de frutas y verduras")

```

En la siguiente tabla \ref{tab:tabla_fruta_verdura} se pueden observar los datos procesados para los productos de fruta y verdura .


## Productos vendidos por unidad

Una vez separados los productos por peso, se procedió a procesar el resto de productos, es decir, aquellos que se venden por unidades. En este caso, se extrajeron datos como la cantidad, el nombre del producto, el precio unitario y el importe total. Se aplicaron técnicas de procesamiento de texto para limpiar y estructurar la información, ya que algunos productos con una sola unidad incluían el precio directamente dentro del nombre del producto.


```{r, include= FALSE}
# Procesamiento resto de productos sin kg

# Identificar las filas de detalles (kg y €/kg)
ind_detalles_kg <- grep("kg.*€/kg", df_sin_pescado$productos, value = FALSE)

# Las filas de nombres están justo antes de los detalles
ind_nombres_kg <- ind_detalles_kg - 1

# Combinar todos los índices a eliminar
filas_fruta_verdura <- sort(unique(c(ind_nombres_kg, ind_detalles_kg)))

# Eliminar filas ya procesadas
df_resto <- df_sin_pescado[-filas_fruta_verdura, ]

df_productos_unidades <- df_resto %>%
  mutate(
    # 1. Extraer cantidad (siempre es el primer número)
    cantidad = as.numeric(str_extract(productos, "^\\d+")),
    
    # 2. Extraer posible precio en el nombre (para productos de 1 unidad)
    precio_en_nombre = ifelse(cantidad == 1,
                            as.numeric(gsub(",", ".", str_extract(productos, "\\d+,\\d+$"))),
                            NA_real_),
    
    # 3. Procesamiento vectorizado de componentes
    componentes = strsplit(productos, "\\s+"),
    
    # 4. Extraer importe normal (para productos con múltiples unidades)
    importe_normal = sapply(componentes, function(x) {
      if(length(x) >= 3) as.numeric(gsub(",", ".", x[length(x)])) else NA_real_
    }),
    
    # 5. Determinar el importe final
    importe = ifelse(!is.na(precio_en_nombre), precio_en_nombre, importe_normal),
    
    # 6. Extraer descripción limpia (MODIFICACIÓN CLAVE)
    nombre = mapply(function(comp, prod, cant, precio_nombre) {
      # Primero eliminar la cantidad inicial (si existe)
      nombre_limpio <- gsub("^\\d+\\s*", "", prod)
      
      if(length(comp) <= 2) return(nombre_limpio)  # Caso simple
      
      if(!is.na(precio_nombre)) {
        # Para productos de 1 unidad: eliminar precio final
        gsub("\\s+\\d+,\\d+$", "", nombre_limpio)
      } else {
        # Para múltiples unidades: eliminar elementos numéricos finales
        paste(comp[2:(length(comp)-2)], collapse=" ")
      }
    }, componentes, productos, cantidad, precio_en_nombre, SIMPLIFY = TRUE) %>%
      str_trim()  # Eliminar espacios sobrantes
  ) %>%
  mutate(
    # 7. Calcular precio unitario
    precio_unitario = importe / cantidad
  ) %>%
  select(num_ticket, nombre, cantidad, precio_unitario, importe)
```

```{r tabla_productos_unidad, echo=FALSE, results='asis'}


knitr::kable(head(df_productos_unidades, 10), align = 'c', format = "latex", booktabs = TRUE,
             caption = "Descripción de variables del conjunto de productos por unidad")

```

En la siguiente tabla \ref{tab:tabla_productos_unidad} se pueden observar los datos procesados para los productos por unidad .


## Conjunto completo de productos

Finalmente, los tres grupos de productos —pescado, frutas y verduras, y productos por unidades— se combinaron en un único data frame unificado. A este conjunto se le añadió una columna adicional que indicaba si el ticket incluía un servicio de aparcamiento, en caso de que esa información estuviera disponible. El resultado fue un data frame final, estructurado y homogéneo, con todos los productos organizados por tipo, cantidad, precio, importe y número de ticket, listo para su análisis posterior.


```{r, include=FALSE}
# dataframe final con todos los productos analizados:

# Añadir columna 'tipo' a cada dataframe
df_pescado <- df_pescado %>% mutate(tipo = "pescado")
df_fruta_verdura <- df_fruta_verdura %>% mutate(tipo = "fruta_verdura")
df_productos_unidades <- df_productos_unidades %>% mutate(tipo = "unidades")

# Unificar columnas para combinar
df_final <- bind_rows(
  df_pescado %>% select(num_ticket, nombre, cantidad = peso_kg, precio = precio_kg, importe, tipo),
  df_fruta_verdura %>% select(num_ticket, nombre, cantidad = peso_kg, precio = precio_kg, importe, tipo),
  df_productos_unidades %>% select(num_ticket, nombre = nombre, cantidad, precio = precio_unitario, importe, tipo)
)

# Crear columna tiene_aparcamiento 
if ("aparcamiento" %in% colnames(df_aparcamiento)) {
  df_aparcamiento <- df_aparcamiento %>%
    mutate(nombre_archivo = basename(archivo)) %>%
    mutate(num_ticket = str_extract(nombre_archivo, "\\d+")) %>%
    mutate(tiene_aparcamiento = !is.na(aparcamiento)) %>%
    select(num_ticket, tiene_aparcamiento)

  # Convertir num_ticket a carácter en ambos dataframes
  df_final <- df_final %>% mutate(num_ticket = as.character(num_ticket))
  df_aparcamiento <- df_aparcamiento %>% mutate(num_ticket = as.character(num_ticket))

  # Combinar los datos
  df_final <- left_join(df_final, df_aparcamiento, by = "num_ticket")
} else {
  df_final$tiene_aparcamiento <- NA  # columna vacía si no existe 'aparcamiento'
}

# Resultado final ordenado
df_final <- df_final %>% arrange(num_ticket)


```

```{r tabla_final, echo=FALSE, results='asis'}

knitr::kable(head(df_final, 10), align = 'c', format = "latex", booktabs = TRUE,
             caption = "Descripción de variables del conjunto de datos final")

```

En la siguiente tabla \ref{tab:tabla_final} se pueden observar los datos procesados para los productos por unidad .












# Preguntas

1- ¿Cuáles son los productos menos vendidos por unidades? ¿Y por kilos?
```{r}

unidades <- df_final[df_final$tipo == "unidades", ]
unidades_agrupadas <- aggregate(cantidad ~ nombre, data = unidades, sum)
unidades_ordenadas <- unidades_agrupadas[order(unidades_agrupadas$cantidad), ]

head(unidades_ordenadas, n = 3)
```

```{r}
kilos <- df_final[df_final$tipo == "fruta_verdura", ]
kilos_agrupados <- aggregate(cantidad ~ nombre, data = kilos, sum)
kilos_ordenados <- kilos_agrupados[order(kilos_agrupados$cantidad), ]
head(kilos_ordenados, n = 3)

```
Respuesta: El producto menos vendido por unidades son PROTEÍNAS CAFÉ, 1/2 POLLO PARTIDO	y 12 HUEVOS MEDIANOS-M.
Y el producto menos vendido por kilo es Pera Rocha con 0.364kg

2-¿Qué productos han generado mayor ingreso total (precio x cantidad)?
```{r}
# Calcular ingreso total por producto (importe = precio × cantidad)
df_final$ingreso_total <- df_final$precio * df_final$cantidad

# Ordenar por ingreso total descendente
productos_ordenados <- df_final[order(-df_final$ingreso_total), ]

# Mostrar los productos con mayor ingreso total

print(productos_ordenados[, c("nombre", "ingreso_total")])

# Top 3 productos con mayor ingreso total

print(head(productos_ordenados[, c("nombre", "ingreso_total")], 3))

```
Respuesta: Como vemos Alistado Mediano con 31.33 es mayor

3-¿Cuál es el ticket con el mayor importe total y qué porcentaje representa este ticket respecto al importe total de todos los tickets?
  
```{r}

# Calcular importe total por ticket y ordenar
ticket_mayor <- df_final %>% group_by(num_ticket) %>% summarise(importe_total = sum(importe, na.rm = TRUE)) %>% arrange(desc(importe_total)) %>%
  head(1)  # Tomamos el primero (mayor importe)

# Importe total general
total_ventas <- sum(df_final$importe, na.rm = TRUE)

# Calcular porcentaje
porcentaje <- round((ticket_mayor$importe_total / total_ventas) * 100, 2)


list( ticket_mayor = ticket_mayor, porcentaje_del_total = paste0(porcentaje, "%"))

```
Respuesta: El ticket con el mayor importe total es el número 397921, con un importe de 234,82 euros.
Este ticket constituye el 1,67% del importe total de todos los tickets.

4-¿Qué productos se compran habitualmente juntos? ¿Que podemos entender sobre la dieta de los clientes?
```{r}
product_pairs <- df_final %>% rename(item1 = nombre) %>% inner_join(df_final, by = "num_ticket") %>%
rename(item2 = nombre) %>% filter(item1 < item2)  
                           # Esto evita pares duplicados y pares del mismo producto


# calcula productos pares
pair_counts <- product_pairs %>% group_by(item1, item2) %>% summarise(frequency = n(), .groups = "drop") %>%
arrange(desc(frequency))

# top 20
head(pair_counts, 20)


```
Respuesta: Has identificado pares de productos más frecuentemente comprados juntos, donde uno de ellos es casi siempre QUESO LONCHAS CABRA. Eso sugiere que este producto es muy popular y acompaña a muchos otros productos a la misma compra.
Observamos que:
1-La presencia de productos sin lactosa y Desnatada indica preocupación para comer más saludable.
2-En conjunto, los hábitos reflejan una dieta equilibrada, con atención a la salud y lo natural.

5-¿Existen diferencias de precios para el mismo producto en diferentes tiendas o ubicaciones?

library(dplyr)
df_final %>%
  group_by(nombre,precio) %>%
  summarise(df$direccion) -> diferencias_precio
print(diferencias precio)



6-¿A que horas del dia hay más ventas?

gasto_diario <- df %>% 
  group_by(hora) %>% 
  summarise(gasto_total_diario= sum(total, na.rm=TRUE)) %>%
  arrange(desc(gasto_total_diario))
print(gasto_diario) 

gasto_total_diario <- gasto_diario %>%
  mutate(hora_limpia= hour(hms(hora))       #Para extraer las horas de 0 a 23

#Agrupar por hora redondeada
gasto_por_hora <- gasto_diario %>%
  mutate(hora_completa=paste0(hora, ":00"), hora_limpia=hour(hms(hora_completa))) %>%
  group_by(hora_limpia) %>%
  summarise(gasto_total = sum(gasto_total_diario, na.rm = TRUE)) %>%
  arrange(desc(gasto_total))
print(gasto_por_hora)

#La hora en la que más se gasta son las 13:00h

ggplot(gasto_por_hora, aes(x = factor(hora_limpia), y = gasto_total, fill = factor(hora_limpia))) +
  geom_col(show.legend = FALSE) +
  labs(title = "Gasto total por horas",
       x = "Hora (número)",
       y = "Gasto total") +
  theme_minimal()


7-En cuantos tickets se venden frutas/verduras y pescados?
```{r}
df_fruta_verdura %>%
  summarise(n_tickets = n_distinct(num_ticket)) %>%
  arrange(desc(n_tickets)) -> tickets_por_mercadona
print(tickets_por_mercadona)

df_pescado %>%
  summarise(n_tickets= n_distinct(num_ticket)) %>%
  arrange(desc(n_tickets)) -> tickets_por_mercadona2
print(tickets_por_mercadona2) 

```
Respuesta: Podemos ver que en 168 tickets se vende fruta o verdura, y en 24 tickets se vende pescado

8-¿Desde qué ciudades se emiten más tickets?

df %>%
  group_by(direccion) %>%
  summarise(n_tickets = n_distinct(num_ticket)) %>%
  arrange(desc(n_ticket)) <- tickets_por_mercadona
print(tickets_por_mercadona)
# Se emiten mas tickets desde el mercadona de "C/Quart 120"

9-¿Existen diferencias de consumo por cada mercadona?
df%>%
  group_by(direccion)
  summarise(
    media_gasto=mean(total, na.rm = TRUE)
    mediana_gasto=median(total,  na.rm = TRUE)
    desv_gasto=sd(total, na.rm = TRUE)
  ) %>%
  arrange(desc(media_gasto)) <- gasto_por_mercadona
print(gasto_por_mercadona)
# Si que hay diferencia de consumo, en cada mercadona la media de consumo es difernete, el mercadona con la media de consumo mas alto es "Avda. del textil 21"


10-¿Que mes y que dia del año es cuando mas dinero se gasta?
# Gasto mensual
gasto_mensual <- df %>%
  group_by(mes) %>%
  summarise(gasto_total_mensual = sum(total, na.rm = TRUE)) %>%
  arrange(desc(gasto_total_mensual))

print(gasto_mensual)
# El mes del año con mas gasto es enero, seguido de marzo y febrero

ggplot(gasto_mensual, aes(x = factor(mes), y = gasto_total_mensual, fill = factor(mes))) +
  geom_col(show.legend = FALSE) +
  labs(title = "Gasto total por mes",
       x = "Mes (número)",
       y = "Gasto total") +
  theme_minimal()


# Gasto diario
gasto_diario <- df %>%
  group_by(dia) %>%
  summarise(gasto_total_diario = sum(total, na.rm = TRUE)) %>%
  arrange(desc(gasto_total_diario))

print(gasto_diario)
# El dia del mes con más gasto es el dia 27 de cada mes 

ggplot(gasto_diario, aes(x = factor(dia), y = gasto_total_diario, fill = factor(dia))) +
  geom_col(show.legend = FALSE) +
  labs(title = "Gasto total por dia",
       x = "Dia (número)",
       y = "Gasto total") +
  theme_minimal()

11-¿Influye la disponibilidad de aparcamiento en el importe total de la compra?
```{r}
resultados <- df_final %>% filter(!is.na(tiene_aparcamiento)) %>% group_by(tiene_aparcamiento) %>%
summarise(
    n_compras = n(),
    media_total = mean(total, na.rm = TRUE),
    mediana_total = median(total, na.rm = TRUE),
    sd_total = sd(total, na.rm = TRUE),
    min_total = min(total, na.rm = TRUE),
    max_total = max(total, na.rm = TRUE)
  ) %>% arrange(desc(media_total))


print(resultados) 



```
Respuesta: No hay datos de aparcamiento, pués no influye.

12-¿Cuál es las categoría de productos con mayor venta en términos de cantidad, y cuál es su contribución porcentual al total de unidades vendidas? Hay relación entre otras categorías?
```{r}

# Calcular total de unidades vendidas por categoría
ventas_por_tipo <- df_final %>% 
  filter(!is.na(tipo)) %>%  
  group_by(tipo) %>%
  summarise(total_unidades = sum(cantidad, na.rm = TRUE)) %>%
  arrange(desc(total_unidades))

# Calcular total general de unidades 
total_unidades_filtrado <- sum(ventas_por_tipo$total_unidades)

# Añadir columna de porcentaje correctamente calculado
ventas_por_tipo <- ventas_por_tipo %>% 
  mutate(porcentaje = round((total_unidades / total_unidades_filtrado) * 100, 2))
ventas_por_tipo
```
Cuanto es el importe total de pescado? Hay relacion entre el consumo de pescado y comprar de pescado?
# En estos códigos, podemos aplicar summarise para obtener el ingreso de pescado y fruta_verdura, y el porcentaje obtenido. Además, podemos ver que dividir importe de categoría entre importe total resulta en obtener un porcentaje que podemos aprovechar en análisis.
```{r}

df_final %>% summarise(total_importe = sum(ingreso_total, na.rm = TRUE),
                       importe_pescado = sum(ingreso_total[tipo == "pescado"], na.rm = TRUE),
                       porcentaje_importe_pescado = importe_pescado / total_importe * 100)

```

```{r}
df_final %>% summarise(total_importe = sum(ingreso_total, na.rm = TRUE),
                       importe_fruta_verdura = sum(ingreso_total[tipo == "fruta_verdura"], na.rm = TRUE),
                       porcentaje_importe_fruta_verdura = importe_fruta_verdura / total_importe * 100)

```
Respuesta: Unidades son mayor en términos de cantidad con 92.71%. Podemos ver que la importe total de pescado es la más baja entre estas tres categorías y también representa aproximadamente el 0.5% de las compras. El porcentaje de los valores vendidos y el costo de esos valores son números bastante cercanos. Se puede decir que el pescado tiene un costo más alto, ya que en relación con la cantidad comprada, tiene una mayor proporción de los costos en comparación con su porcentaje de compra.